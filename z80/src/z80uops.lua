--[[
Copyright (c) 2013-14 Juan Carlos González Amestoy

Permission is hereby granted, free of charge, to any person obtaining a copy
of this software and associated documentation files (the "Software"), to deal
in the Software without restriction, including without limitation the rights
to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
copies of the Software, and to permit persons to whom the Software is
furnished to do so, subject to the following conditions:

The above copyright notice and this permission notice shall be included in
all copies or substantial portions of the Software.

THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN
THE SOFTWARE.
--]]

local h=require('h')
local util=require('h.text.util')
local bit=require('bit')
local file=require('h.io.file')

local filename=arg[1]

local band,bor,bxor,rs,ls=bit.band,bit.bor,bit.bxor,bit.rshift,bit.lshift
local inst,ddInst,fdInst,edInst,cbInst,ddcbInst,fdcbInst={},{},{},{},{},{},{},{}

local low={
  bc='c',
  de='e',
  hl='l',
  af='f',
  sp='spl',
  ix='ixl',
  iy='iyl',
  pc='pcl',
  tm='tm1',
  aux='auxl'
}

local high={
  bc='b',
  de='d',
  hl='h',
  af='a',
  sp='sph',
  ix='ixh',
  iy='iyh',
  pc='pch',
  tm='tm2',
  aux='auxh'
}

local cache={}

local headerText={}
local sourceText={}
local lines={}

local copyright=[[
/*
Copyright (c) 2013 Juan Carlos González Amestoy

Permission is hereby granted, free of charge, to any person obtaining a copy
of this software and associated documentation files (the "Software"), to deal
in the Software without restriction, including without limitation the rights
to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
copies of the Software, and to permit persons to whom the Software is
furnished to do so, subject to the following conditions:

The above copyright notice and this permission notice shall be included in
all copies or substantial portions of the Software.

THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN
THE SOFTWARE.
*/

//Autogenerated by src/z80uops.lua don't touch.

]]

headerText[#headerText+1]=copyright
sourceText[#sourceText+1]=copyright
lines[#lines+1]=copyright

local include=util.format('#include "zuops.h"\n\n',filename)

headerText[#headerText+1]='#include "z80.h"\n\n'

sourceText[#sourceText+1]=include
lines[#lines+1]=include

local headerOpTemplate=[[
void %s(z80 *z);]]

local sourceOpTemplate=[[
void %s(z80 *z)
{
%s
}
]]

local function generateOp(name,code)
  local r=cache[name]

  if not r then
    r=name
    cache[name]=name
    headerText[#headerText+1]=util.format(headerOpTemplate,name)
    sourceText[#sourceText+1]=util.format(sourceOpTemplate,name,code)
  end

  return r
end

local function generateI(group,op,name,code,...)
  --print(name,code,...)
  local ops={...}

  if #ops>0 then 
    lines[#lines+1]=util.format('static inst %s_uops[]={%s,NULL};\n',name,table.concat(ops,',')) 
    code=util.format([[
  z->uops=%s_uops;
%s]],name,code)
  end

  lines[#lines+1]=util.format(sourceOpTemplate,name,code)
  group[op]=name
end

local function generateI2(group,op,name,code,o1,o2)
  if o1 and #o1>0 then 
    lines[#lines+1]=util.format('static inst %s_uops1[]={%s,NULL};\n',name,table.concat(o1,',')) 
  end

  if o2 and #o2>0 then 
    lines[#lines+1]=util.format('static inst %s_uops2[]={%s,%s,NULL};\n',name,table.concat(o1,','),table.concat(o2,',')) 
  end

  lines[#lines+1]=util.format(sourceOpTemplate,name,code)
  group[op]=name
end

local function generateI2a(group,op,name,code,o1,o2)
  if o1 and #o1>0 then 
    lines[#lines+1]=util.format('static inst %s_uops1[]={%s,NULL};\n',name,table.concat(o1,',')) 
  end

  if o2 and #o2>0 then 
    lines[#lines+1]=util.format('static inst %s_uops2[]={%s,NULL};\n',name,table.concat(o2,',')) 
  end

  lines[#lines+1]=util.format(sourceOpTemplate,name,code)
  group[op]=name
end

-----------------------------
-- Read ---------------------
-----------------------------

--Read operation
local function readOp(dest,source,time)
  local key=util.format('z80Read_%s_%s_%s',source,dest,time)

  return   generateOp(key,util.format([[
  z->r.%s=z->get(z,z->r.%s);
  z->T=%s;]],dest,source,time))
end

--Read operation Increment
local function readIncOp(dest,source,time)
  local key=util.format('z80ReadInc_%s_%s_%s',source,dest,time)

  return   generateOp(key,util.format([[
  z->r.%s=z->get(z,z->r.%s++);
  z->T=%s;]],dest,source,time))
end


--Read Indexed
local function readIOp(dest,source,time)
  local key=util.format('z80ReadI_%s_%s_%s',source,dest,time)
  
  return generateOp(key,util.format([[
z->r.mptr=z->r.%s+((int8_t)z->r.tm1);
  z->r.%s=z->get(z,z->r.mptr);
  z->T=%s;]],source,dest,time))
end

------------------------------
-- Write ---------------------
------------------------------

--Write operation
local function writeOp(source,value,time)
  local key=util.format('z80Write_%s_%s_%s',source,value,time)
  return generateOp(key,util.format([[
  z->set(z,z->r.%s,z->r.%s);
  z->T=%s;]],source,value,time))
end

--Write operation
local function writeIncOp(source,value,time)
  local key=util.format('z80WriteInc_%s_%s_%s',source,value,time)
  return generateOp(key,util.format([[
  z->set(z,z->r.%s++,z->r.%s);
  z->T=%s;]],source,value,time))
end

--Write predecrement operation
local function writeDecOp(source,value,time)
  local key=util.format('z80WriteDec_%s_%s_%s',source,value,time)
  return generateOp(key,util.format([[
  z->set(z,--z->r.%s,z->r.%s);
  z->T=%s;]],source,value,time))
end

--Read Indexed
local function writeIOp(source,value,time)
  local key=util.format('z80WriteI_%s_%s_%s',source,value,time)

  return  generateOp(key,util.format([[
  z->r.mptr=z->r.%s+((int8_t)z->r.tm1);
  z->set(z,z->r.mptr,z->r.%s);
  z->T=%s;]],source,value,time))
end

-----------------------------
--- IO ----------------------
-----------------------------

local function inOp(dest,source,time)
  local key=util.format('z80In_%s_%s_%s',source,dest,time)

  return   generateOp(key,util.format([[
  z->r.%s=z->in(z,z->r.%s);
  z->T=%s;]],dest,source,time))
end

local function outOp(source,value,time)
  local key=util.format('z80Out_%s_%s_%s',source,value,time)
  return generateOp(key,util.format([[
  z->out(z,z->r.%s,z->r.%s);
  z->T=%s;]],source,value,time))
end

-----------------------------
--- Contention --------------
-----------------------------

local function cont1Op(source,time)
  local key=util.format('z80Con1_%s_%s',source,time)

  return  generateOp(key,util.format([[
  z->T=%s+z->con1(z,z->r.%s);]],time,source))
end

local function cont1DecOp(source,time)
  local key=util.format('z80ConDec1_%s_%s',source,time)

  return  generateOp(key,util.format([[
  z->T=%s+z->con1(z,z->r.%s-1);]],time,source))
end

local function cont1iOp(source,time)
  local key=util.format('z80Con1i_%s_%s',source,time)

  return  generateOp(key,util.format([[
  z->T=%s+z->con1(z,z->r.%s+((int8_t)z->r.tm1));]],time,source))
end

local function cont2Op(source,time)
  local key=util.format('z80Con2_%s_%s',source,time)

  return  generateOp(key,util.format([[
  z->T=%s+z->con2(z,z->r.%s);]],time,source))
end

local function contIOOp(source,time)
  local key=util.format('z80ConIO_%s_%s',source,time)

  return  generateOp(key,util.format([[
  z->T=%s+z->conIO(z,z->r.%s);]],time,source))
end

--------------------------------
--- z80 Implementation ---------
--------------------------------

lines[#lines+1]=[[
#define _LOOKUP uint8_t l=((z->r.a&0x88)>>3) | ((v & 0x88)>>2) | ((r&0x88)>>1);
#define _LOOKUP2 uint8_t l=((((uint8_t)(v-1))&0x88)>>3) | ((v&0x88)>>1);
#define _LOOKUP3 uint8_t l=((((uint8_t)(v+1))&0x88)>>3) | ((v&0x88)>>1);
#define _LOOKUP16 uint8_t l=((o&0x8800)>>11) | ((v & 0x8800)>>10) | ((r&0x8800)>>9);
#define _LOOKUP16ADD uint8_t l=((o&0x0800)>>11) | ((v & 0x0800)>>10) | ((r&0x0800)>>9);

uint8_t sz53cFlags[0x200]={]]

lines[#lines+1]=''
for v=0,0x1ff do
  --local v=i+j
  local f=band(v,0xA8)
  if band(v,0x100)~=0 then f=bor(f,0x1) end
  if band(v,0xff)==0 then f=bor(f,0x40) end --Z
  lines[#lines]=lines[#lines]..util.format("0x%.2x,",f)
end
lines[#lines+1]=[[
};]]

lines[#lines+1]=[[
uint8_t sz53pcFlags[0x200]={]]
lines[#lines+1]=''
for v=0,0x1ff do
  --local v=i+j
  local f=band(v,0xA8)
  local j,p=band(v,0xff),0
  for k=0,7 do 
    p=bxor(p,band(j,1))
    j=rs(j,1)
  end
  if p==0 then f=bor(f,0x4) end
  if band(v,0x100)~=0 then f=bor(f,0x1) end
  if band(v,0xff)==0 then f=bor(f,0x40) end --Z
  lines[#lines]=lines[#lines]..util.format("0x%.2x,",f)
end
lines[#lines+1]=[[
};]]

lines[#lines+1]=[[
const uint8_t hAddFlags[]={
  0,0x10,0x10,0x10,0,0,0,0x10
};

const uint8_t hSubFlags[]={
  0,0,0x10,0,0x10,0,0x10,0x10
};

const uint8_t vAddFlags[]={
  0,0,0,0x4,0x4,0,0,0
};

const uint8_t vSubFlags[]={
  0,0x4,0,0,0,0,0x4,0
};
]]

------------------------------------
-- Prefix --------------------------
------------------------------------

local function prefix(o)
  generateI(inst,o,util.format('z80Prefix%x',o),[[
  z->T=4;
  ]],
    generateOp(util.format('z80PrefixOp%x',o),util.format([[
  uint8_t c=z->con1(z,z->r.pc);
  uint8_t opc=z->get(z,z->r.pc++);

  z->r.r=((z->r.r+1) & 0x7f) | (z->r.r & 0x80);
  z->flags|=0x2;
  %xInst[opc](z);
  z->T+=c;]],o))
  )

  --inst[o]=util.format('prefix%x',o)
end

local function prefix2(o,p,i)
  generateI(i,o,util.format('z80Prefix2%s',p),[[
  z->T=4;]],
    cont1Op('pc',2),
    readIncOp('tm1','pc',1),
    generateOp(util.format('z80Prefix2Op%s',p),util.format([[
  uint8_t c=z->con1(z,z->r.pc);
  uint8_t opc=z->get(z,z->r.pc++);

  %sInst[opc](z);
  z->T+=c;]],p))
  )

  --i[o]=util.format('prefix2%x',o)
end

prefix(0xdd)
ddInst[0xdd]=inst[0xdd]
fdInst[0xdd]=inst[0xdd]
prefix(0xfd)
ddInst[0xfd]=inst[0xfd]
fdInst[0xfd]=inst[0xfd]
prefix(0xed)
prefix(0xcb)

prefix2(0xcb,'ddcb',ddInst)
prefix2(0xcb,'fdcb',fdInst)

------------------------------------
-- Nop -----------------------------
------------------------------------

generateI(inst,0x0,'nop',[[
  z->r.q=0;
  z->T=4;]])

------------------------------------
-- Halt ----------------------------
------------------------------------

generateI(inst,0x76,'halt',[[
  z->r.q=0;
  z->flags=z80HALTED;
  z->T=4;]])

------------------------------------
-- ld r,r --------------------------
------------------------------------

local function loadr(d,s,o)
  local i=inst
  if h.eqAny(d,'ixh','ixl') or h.eqAny(s,'ixl','ixh') then
    i=ddInst
  elseif h.eqAny(d,'iyh','iyl') or h.eqAny(s,'iyl','iyh') then
    i=fdInst
  end

  local name=util.format('z80ldr_%s_%s',d,s)

  generateI(i,o,name,util.format([[
  z->r.q=0;
  z->r.%s=z->r.%s;
  z->T=4;]],d,s))
end

------------------------------------
-- ld r,n --------------------------
------------------------------------

local function loadrn(s,o)
  local i=inst
  if h.eqAny(d,'ixh','ixl') or h.eqAny(s,'ixl','ixh') then
    i=ddInst
  elseif h.eqAny(d,'iyh','iyl') or h.eqAny(s,'iyl','iyh') then
    i=fdInst
  end

  local name=util.format('z80ldr_%s_n',s)

  generateI(i,o,name,util.format([[
  z->r.q=0;
  z->T=4;]]),
    cont1Op('pc',2),readIncOp(s,'pc',1)
  )
end 

------------------------------------
-- ld r,(rr) -----------------------
------------------------------------

local function loadri(d,s,o)
  local name=util.format('z80ldri_%s_%s',d,s)

  if h.eqAny(s,'bc','de') then
    generateI(inst,o,name,util.format([[
  z->r.mptr=z->r.%s;
  z->r.q=0;
  z->T=4;]],s),
      cont1Op(s,2),readOp(d,'mptr',1)
    )
  else
    generateI(inst,o,name,util.format([[
  z->r.q=0;
  z->T=4;]],s),
      cont1Op(s,2),readOp(d,s,1)
    )
  end
end

------------------------------------
-- ld r,(rr+d) ---------------------
------------------------------------

local function loadrid(d,s,o)
  local i=s=='ix' and ddInst or fdInst

  local name=util.format('z80ldrid_%s_%s',d,s)

  generateI(i,o,name,util.format([[
  z->r.q=0;
  z->T=4;]]),
    cont1Op('pc',2),
    readIncOp('tm1','pc',1),
    cont2Op('pc',1),
    cont2Op('pc',1),
    cont2Op('pc',1),
    cont2Op('pc',1),
    cont2Op('pc',1),
    cont1iOp(s,2),
    readIOp(d,s,1)
  )
end

------------------------------------
-- ld (rr),r -----------------------
------------------------------------

local function storei(d,s,o)
  local name=util.format('z80stoi_%s_%s',d,s)

  generateI(inst,o,name,[[
  z->r.q=0;
  z->T=4;]],
    cont1Op(d,2),writeOp(d,s,1)
  )
end

--for mptr implementation
local function storei2(d,s,o)
  local name=util.format('z80stoi_%s_%s',d,s)

  generateI(inst,o,name,util.format([[
  z->r.mptr=z->r.%s;
  z->r.q=0;
  z->T=4;]],d),
    cont1Op(d,2),generateOp(name..'Op',util.format([[
  z->set(z,z->r.mptr++,z->r.%s);
  z->r.mptrh=z->r.a;
  z->T=1;]],s))
  )
end

------------------------------------
-- ld (rr+d),r ---------------------
------------------------------------

local function storeid(d,s,o)
  local i=d=='ix' and ddInst or fdInst

  local name=util.format('z80stoid_%s_%s',d,s)

  generateI(i,o,name,[[
    z->r.q=0;
    z->T=4;
  ]],
    cont1Op('pc',2),
    readIncOp('tm1','pc',1),
    cont2Op('pc',1),
    cont2Op('pc',1),
    cont2Op('pc',1),
    cont2Op('pc',1),
    cont2Op('pc',1),
    cont1iOp(s,2),
    writeIOp(d,s,1) 
  )
end

------------------------------------
-- ld (rr),n -----------------------
------------------------------------

generateI(inst,0x36,'storn',[[
  z->r.q=0;
  z->T=4;
]],
  cont1Op('pc',2),readIncOp('tm1','pc',1),cont1Op('hl',2),writeOp('hl','tm1',1)
)

------------------------------------
-- ld (rr+d),n ---------------------
------------------------------------

local function stornd(d)
  local i=d=='ix' and ddInst or fdInst
  local name='storn'..d

  generateI(i,0x36,name,[[
  z->r.q=0;
  z->T=4;]],
    cont1Op('pc',2),
    readIncOp('tm1','pc',1),
    cont1Op('pc',2),
    readIncOp('tm2','pc',1),
    cont2Op('pc',1),
    cont2Op('pc',1),
    cont1iOp(d,2),
    writeIOp(d,'tm2',1)
  )
end

r8={[0]='b','c','d','e','h','l',[7]='a'}
r8ix={b='b',c='c',d='d',e='e',h='ixh',l='ixl',a='a'}
r8iy={b='b',c='c',d='d',e='e',h='iyh',l='iyl',a='a'}

for i,s in pairs(r8) do
  for j,d in pairs(r8) do
    loadr(d,s,64+j*8+i)
    if h.eqAny(s,'h','l') or h.eqAny(d,'h','l') then
      loadr(r8ix[d],r8ix[s],64+j*8+i)
      loadr(r8iy[d],r8iy[s],64+j*8+i)
    end
  end

  loadrn(s,i*8+6)
  loadri(s,'hl',64+i*8+6)
  loadrid(s,'ix',64+i*8+6)
  loadrid(s,'iy',64+i*8+6)
  storei('hl',s,64+6*8+i)
  storeid('ix',s,64+6*8+i)
  storeid('iy',s,64+6*8+i)

  if h.eqAny(s,'h','l') then
    loadrn(r8ix[s],i*8+6)
    loadrn(r8iy[s],i*8+6)
  end
end

stornd('ix')
stornd('iy')

loadri('a','bc',0xa)
loadri('a','de',0x1a)

storei2('bc','a',0x2)
storei2('de','a',0x12)

------------------------------------
-- ld a,(nn) -----------------------
------------------------------------
generateI(inst,0x3a,'ldamem',[[
  z->r.q=0;
  z->T=4;
]],
  cont1Op('pc',2),
  readIncOp('mptrl','pc',1),
  cont1Op('pc',2),
  readIncOp('mptrh','pc',1),
  cont1Op('mptr',2),
  readIncOp('a','mptr',1)
)

------------------------------------
-- ld (nn),a -----------------------
------------------------------------
generateI(inst,0x32,'stamem',[[
  z->r.q=0;
  z->T=4;
]],
  cont1Op('pc',2),
  readIncOp('mptrl','pc',1),
  cont1Op('pc',2),
  readIncOp('mptrh','pc',1),
  cont1Op('mptr',2),
  generateOp('stamemOp',[[
  z->set(z,z->r.mptr++,z->r.a);
  z->r.mptrh=z->r.a;
  z->T=1;
  ]])
)

------------------------------------
-- ld a,[ir] -----------------------
------------------------------------

local function ldari(s,o)
  local name='ldr_a_'..s

  generateI(edInst,o,name,util.format([[
  z->r.a=z->r.%s;

  z->r.f=(z->r.f & 0x1) | (sz53cFlags[z->r.a] & 0xe8) | ((z->r.iff2 & 0x1) <<2);
  z->r.q=1;
  z->T=4; 
  ]],s),
    cont2Op('ir',1)
  )
end

ldari('i',0x57)
ldari('r',0x5f)

------------------------------------
-- ld [ir],a -----------------------
------------------------------------

local function ldria(s,o)
  local name='ldr_'..s..'_a'

  generateI(edInst,o,name,util.format([[
  z->r.tm=z->r.ir;
  z->r.%s=z->r.a;
  z->r.q=0;
  z->T=4;  
  ]],s),
    cont2Op('tm',1)
  )
end

ldria('i',0x47)
ldria('r',0x4f)

------------------------------------
--16-bits load group----------------
------------------------------------

------------------------------------
-- ld rr,nn ------------------------
------------------------------------

local function load16r(d,o,g)
  local name='ld16r_'..d

  generateI(g,o,name,[[
    z->r.q=0;
    z->T=4;
  ]],
    cont1Op('pc',2),
    readIncOp(low[d],'pc',1),
    cont1Op('pc',2),
    readIncOp(high[d],'pc',1)
  )
end

load16r('bc',0x01,inst) --ld bc,nn
load16r('de',0x11,inst) --ld de,nn
load16r('hl',0x21,inst) --ld hl,nn
load16r('sp',0x31,inst) --ld sp,nn
load16r('ix',0x21,ddInst) --ld ix,nn
load16r('iy',0x21,fdInst) --ld iy,nn


------------------------------------
-- ld rr,(nn) ----------------------
------------------------------------

local function load16ri(d,o,g,p)
  if not p then p='' end

  local name='ld16ri'..d..p

  generateI(g,o,name,[[
  z->r.q=0;
  z->T=4;
  ]],
    cont1Op('pc',2),
    readIncOp('mptrl','pc',1),
    cont1Op('pc',2),
    readIncOp('mptrh','pc',1),
    cont1Op('mptr',2),
    readIncOp(low[d],'mptr',1),
    cont1Op('mptr',2),
    readOp(high[d],'mptr',1)
  )
end

load16ri('hl',0x2a,inst) --ld hl,(nn)
load16ri('bc',0x4b,edInst) --ld bc,(nn)
load16ri('de',0x5b,edInst) --ld de,(nn)
load16ri('hl',0x6b,edInst,'2') --ld hl,(nn)
load16ri('sp',0x7b,edInst) --ld sp,(nn)
load16ri('ix',0x2a,ddInst) --ld ix,(nn)
load16ri('iy',0x2a,fdInst) --ld iy,(nn)

------------------------------------
-- ld (nn),rr ----------------------
------------------------------------

local function store16ri(d,o,g,p)
  if not p then p='' end

  local name='st16ri'..d..p

  generateI(g,o,name,[[
  z->r.q=0;
  z->T=4;
  ]],
    cont1Op('pc',2),
    readIncOp('mptrl','pc',1),
    cont1Op('pc',2),
    readIncOp('mptrh','pc',1),
    cont1Op('mptr',2),
    writeIncOp('mptr',low[d],1),
    cont1Op('mptr',2),
    writeOp('mptr',high[d],1)
  )
end

store16ri('hl',0x22,inst) --ld (nn),hl
store16ri('bc',0x43,edInst) --ld (nn),bc
store16ri('de',0x53,edInst) --ld (nn),de
store16ri('hl',0x63,edInst,'2') --ld (nn),hl
store16ri('sp',0x73,edInst) --ld (nn),sp
store16ri('ix',0x22,ddInst) --ld (nn),ix
store16ri('iy',0x22,fdInst) --ld (nn),iy

------------------------------------
-- ld rr,rr ------------------------
------------------------------------

local function load16r(d,s,o,g)
  local name=util.format('ld16r_%s_%s',d,s)

  generateI(g,o,name,util.format([[
    z->r.%s=z->r.%s;
    z->r.q=0;
    z->T=4;
  ]],d,s),
    cont2Op('ir',1),
    cont2Op('ir',1)
  )
end

load16r('sp','hl',0xf9,inst)
load16r('sp','ix',0xf9,ddInst)
load16r('sp','iy',0xf9,fdInst)

------------------------------------
-- push rr -------------------------
------------------------------------

local function pushr(d,o,g)
  local name='push'..d

  generateI(g,o,name,[[
    z->r.q=0;
    z->T=4;
  ]],
    cont2Op('ir',1),
    cont1DecOp('sp',2),
    writeDecOp('sp',high[d],1),
    cont1DecOp('sp',2),
    writeDecOp('sp',low[d],1)
  )
end

pushr('bc',0xc5,inst)
pushr('de',0xd5,inst)
pushr('hl',0xe5,inst)
pushr('af',0xf5,inst)
pushr('ix',0xe5,ddInst)
pushr('iy',0xe5,fdInst)


------------------------------------
-- pop rr --------------------------
------------------------------------

local function popr(d,o,g)
  local name='pop'..d

  generateI(g,o,name,[[
  z->r.q=0;
  z->T=4;
  ]],
    cont1Op('sp',2),
    readIncOp(low[d],'sp',1),
    cont1Op('sp',2),
    readIncOp(high[d],'sp',1)
  )
end

popr('bc',0xc1,inst)
popr('de',0xd1,inst)
popr('hl',0xe1,inst)
popr('af',0xf1,inst)
popr('ix',0xe1,ddInst)
popr('iy',0xe1,fdInst)

----------------------------------------------
--Exchange, Block Transfer, and Search Group--
----------------------------------------------

------------------------------------
-- ex de,hl ------------------------
------------------------------------

generateI(inst,0xeb,'exdehl',[[
  uint16_t l=z->r.de;
  z->r.de=z->r.hl;
  z->r.hl=l;

  z->r.q=0;
  z->T=4;
]])

------------------------------------
-- ex af,af' -----------------------
------------------------------------

generateI(inst,0x08,'exafaf',[[
  uint16_t l=z->r.af;
  z->r.af=z->r.afp;
  z->r.afp=l;

  z->r.q=0;
  z->T=4;
]])

------------------------------------
-- exx  ----------------------------
------------------------------------

generateI(inst,0xd9,'exx',[[
  uint16_t lbc=z->r.bc;
  uint16_t lde=z->r.de;
  uint16_t lhl=z->r.hl;
  z->r.bc=z->r.bcp;
  z->r.de=z->r.dep;
  z->r.hl=z->r.hlp;
  z->r.bcp=lbc;
  z->r.dep=lde;
  z->r.hlp=lhl;

  z->r.q=0;
  z->T=4; 
]])

------------------------------------
-- ex rr,(sp) ----------------------
------------------------------------

local function exspi(d,o,g,t,m)
  local name='exsp'..d

  generateI(g,o,name,[[
  z->r.q=0;
  z->T=4;
  ]],
    cont1Op('sp',2),
    readIncOp('mptrl','sp',1),
    cont1Op('sp',2),
    readOp('mptrh','sp',1),
    cont2Op('sp',1),
    cont1Op('sp',2),
    writeOp('sp',high[d],1),
    cont1DecOp('sp',2),
    writeDecOp('sp',low[d],1),
    cont2Op('sp',1),
    generateOp(name..'Op',util.format([[
      z->r.%s=z->r.mptr;
      z->T=1+z->con2(z,z->r.sp);;
    ]],d))
  )
end

exspi('hl',0xe3,inst)
exspi('ix',0xe3,ddInst)
exspi('iy',0xe3,fdInst)

------------------------------------
-- ldi / ldd  ----------------------
------------------------------------

local function ld(o,i,s)
  local name='ld'..s

  generateI(edInst,o,name,util.format([[
  z->T=4;
  ]]),
    cont1Op('hl',2),
    readOp('tm1','hl',1),
    cont1Op('de',2),
    writeOp('de','tm1',1),
    cont2Op('de',1),
    generateOp(name..'Op',util.format([[
  z->r.hl+=%d;
  z->r.de+=%d;
  z->r.bc--;

  uint8_t n=z->r.a+z->r.tm1;
  z->r.f=(z->r.f & 0xc1) | (n & 0x8) | ((n & 0x2)<<4);
  z->r.f=(z->r.bc!=0) ? z->r.f | 0x4 : z->r.f;
  z->r.q=1;

  z->T=1+z->con2(z,z->r.de);
    ]],i,i))
  )
end

ld(0xa0,1,'i')
ld(0xa8,-1,'d')

------------------------------------
-- ldir / lddr  --------------------
------------------------------------

local function ldr(o,i,s)
  local name='ld'..s..'r'

  generateI2(edInst,o,name,util.format([[
    z->r.bc--;
    z->r.aux=z->r.de;
    if(z->r.bc)
      z->uops=%s_uops2;
    else
      z->uops=%s_uops1;

    z->T=4;
  ]],name,name),{
    cont1Op('hl',2),
    readOp('tm1','hl',1),
    cont1Op('aux',2),
    writeOp('aux','tm1',1),
    cont2Op('aux',1),
    generateOp(name..'Op',util.format([[
  z->r.hl+=%d;
  z->r.de+=%d;
  
  uint8_t n=z->r.a+z->r.tm1;
  z->r.f=(z->r.f & 0xc1) | (n & 0x8) | ((n & 0x2)<<4);
  if(z->r.bc)
  {
    z->r.pc-=2;
    z->r.f=z->r.f | 0x4;
    z->r.mptr=z->r.pc+1;
  }
  z->r.q=1;  

  z->T=1+z->con2(z,z->r.aux);   
    ]],i,i))
  },{
    cont2Op('aux',1),
    cont2Op('aux',1),
    cont2Op('aux',1),
    cont2Op('aux',1),
    cont2Op('aux',1),
  })
end

ldr(0xb0,1,'i')
ldr(0xb8,-1,'d')

------------------------------------
-- cpi / cpd  ----------------------
------------------------------------

local function cpr(o,i,s)
  local name='cp'..s

  generateI(edInst,o,name,[[
    z->T=4;
  ]],
    cont1Op('hl',2),
    readOp('tm1','hl',1),
    cont2Op('hl',1),
    cont2Op('hl',1),
    cont2Op('hl',1),
    cont2Op('hl',1),
    generateOp(name..'Op',util.format([[
  uint8_t v=z->r.tm1;
  uint8_t r=z->r.a-v;

  _LOOKUP

  z->r.hl+=%d;
  z->r.mptr+=%d;
  z->r.bc--;

  if(hSubFlags[l&0x7])
  {
    uint8_t n=r-1;
    z->r.f=(sz53cFlags[r] & 0xc0) | (n & 0x8) | ((n & 0x2) << 4) | ((z->r.bc!=0) ? 0x4 : 0) | 0x12 | (z->r.f & 0x1);
  }
  else
    z->r.f=(sz53cFlags[r] & 0xc0) | (r & 0x8) | ((r & 0x2) << 4) | ((z->r.bc!=0) ? 0x4 : 0) | 0x2 | (z->r.f & 0x1);

  z->r.q=1;

  z->T=1+z->con2(z,z->r.hl); 
    ]],i,i))
  )
end

cpr(0xa1,1,'i')
cpr(0xa9,-1,'d')

------------------------------------
-- cpir / cpdr  --------------------
------------------------------------

local function cprr(o,i,s)
  local name='cp'..s..'r'

  generateI2a(edInst,o,name,util.format([[
  z->uops=%s_uops1;
  z->r.aux=z->r.hl;
  z->T=4;
  ]],name),{
    cont1Op('aux',2),
    readOp('tm1','aux',1),
    cont2Op('aux',1),
    cont2Op('aux',1),
    cont2Op('aux',1),
    cont2Op('aux',1),
    generateOp(name..'Op',util.format([[
  uint8_t v=z->r.tm1;
  uint8_t r=z->r.a-v;
  _LOOKUP

  z->r.hl+=%d;
  z->r.bc--;

  if(hSubFlags[l&0x7])
  {
    uint8_t n=r-1;
    z->r.f=(sz53cFlags[r] & 0xc0) | (n & 0x8) | ((n & 0x2) << 4) | ((z->r.bc!=0) ? 0x4 : 0) | 0x12 | (z->r.f & 0x1);
  }
  else
    z->r.f=(sz53cFlags[r] & 0xc0) | (r & 0x8) | ((r & 0x2) << 4) | ((z->r.bc!=0) ? 0x4 : 0) | 0x2 | (z->r.f & 0x1);

  if(r==0 || z->r.bc==0)
  {
    z->r.mptr+=%d;
  }
  else
  {
    z->uops=%s_uops2;
    z->r.pc-=2;
    z->r.mptr=z->r.pc+1;
  }

  z->r.q=1;
  z->T=1+z->con2(z,z->r.aux); 
  ]],i,i,name))
  },{
    cont2Op('aux',1),
    cont2Op('aux',1),
    cont2Op('aux',1),
    cont2Op('aux',1),
    cont2Op('aux',1),
  })
end

cprr(0xb1,1,'i')
cprr(0xb9,-1,'d')

--------------------------
--8-Bit Arithmetic Group--
--------------------------

local function arithmetic8(s,o,g,name,oper,discard)
  local fname=name..'8_'..s

  local ops
  local tail=discard and 'z->T=1;' or 'z->r.a=(uint8_t)r; z->T=1;'

  if s=='hl' then
    ops={
      cont1Op('hl',2),
      generateOp(fname..'Op',util.format([[
        uint8_t v=z->get(z,z->r.hl);
        %s
        z->T=1;
      ]],oper)..tail)
    }
  elseif h.eqAny(s,'ix','iy') then
    ops={
    cont1Op('pc',2),
    readIncOp('tm1','pc',1),
    cont2Op('pc',1),
    cont2Op('pc',1),
    cont2Op('pc',1),
    cont2Op('pc',1),
    cont2Op('pc',1),
    cont1iOp(s,2),
    generateOp(fname..'Op',util.format([[
    uint8_t v=z->get(z,z->r.%s+((int8_t)z->r.tm1));
    %s
    z->T=1;
    ]],s,oper)..tail)}
  elseif s=='nn' then
    ops={
      cont1Op('pc',2),
      generateOp(fname..'Op',util.format([[
      uint8_t v=z->get(z,z->r.pc++);
      %s
      z->T=1;
      ]],oper)..tail)
    }
  end

  if ops then
    generateI(g,o,fname,[[
      z->T=4;
      z->r.q=1;
    ]],unpack(ops))
  else
    generateI(g,o,fname,util.format([[
  uint8_t v=z->r.%s;
  %s
  ]]
  .. (discard and '' or 'z->r.a=(uint8_t)r;\n')..
  [[
  z->T=4;
  z->r.q=1;
    ]],s,oper))
  end
end

--add
local function add8(s,o,g)
  arithmetic8(s,o,g,'add',[[
  uint16_t r=z->r.a+v;
  _LOOKUP
  
  z->r.f=sz53cFlags[r&0x1ff] | hAddFlags[l&0x7] | vAddFlags[l>>4];
  ]])
end


--add
local function adc8(s,o,g)
  arithmetic8(s,o,g,'adc',[[
  uint16_t r=z->r.a+v+(z->r.f & 0x1);
  _LOOKUP
  
  z->r.f=sz53cFlags[r&0x1ff] | hAddFlags[l&0x7] | vAddFlags[l>>4];
  ]])
end

local function sub8(s,o,g)
  arithmetic8(s,o,g,'sub',[[
  uint16_t r=z->r.a-v;
  _LOOKUP

  z->r.f=sz53cFlags[r&0x1ff] | hSubFlags[l&0x7] | vSubFlags[l>>4] | 0x2;
  ]])
end

local function sbc8(s,o,g)
  arithmetic8(s,o,g,'sbc',[[
  uint16_t r=z->r.a-v-(z->r.f & 0x1);
  _LOOKUP

  z->r.f=sz53cFlags[r&0x1ff] | hSubFlags[l&0x7] | vSubFlags[l>>4] | 0x2;
  ]])
end

local function and8(s,o,g)
  arithmetic8(s,o,g,'and',[[
  uint8_t r=z->r.a & v;
  
  z->r.f=(sz53pcFlags[r] & 0xEC) | 0x10;
  ]])
end

local function or8(s,o,g)
  arithmetic8(s,o,g,'or',[[
  uint8_t r=z->r.a | v;
  
  z->r.f=(sz53pcFlags[r] & 0xEC);
  ]])
end

local function xor8(s,o,g)
  arithmetic8(s,o,g,'xor',[[
  uint8_t r=z->r.a ^ v;
  
  z->r.f=(sz53pcFlags[r] & 0xEC);
  ]])
end

local function cp8(s,o,g)
  arithmetic8(s,o,g,'cp',[[
  uint16_t r=z->r.a-v;
  _LOOKUP

  z->r.f=(sz53cFlags[r&0x1ff]  & 0xd7) | (v & 0x28) | hSubFlags[l&0x7] | vSubFlags[l>>4] | 0x2;
  ]],true)
end

local function incdec8(s,o,g,name,d,flags)
  local fname=name..'8_'..s

  local ops

  if s=='hl' then
    ops={
      cont1Op('hl',2),
      readOp('tm2','hl',1),
      generateOp(fname..'Op',util.format([[
      uint8_t v=z->r.tm2+%d;
      z->r.tm2=v;
      %s
      z->T=1+z->con2(z,z->r.%s);
    ]],d,flags,s)),
      cont1Op('hl',2),
      writeOp('hl','tm2',1)
    }
  elseif h.eqAny(s,'ix','iy') then
    ops={
      cont1Op('pc',2),
      readIncOp('tm1','pc',1),
      cont2Op('pc',1),
      cont2Op('pc',1),
      cont2Op('pc',1),
      cont2Op('pc',1),
      cont2Op('pc',1),
      cont1iOp(s,2),
      readIOp('tm2',s,1),
      generateOp(fname..'Op',util.format([[
      uint8_t v=z->r.tm2+%d;
      z->r.tm2=v;
      %s
      z->T=1+z->con2(z,z->r.mptr);
    ]],d,flags,s)),
      cont1Op('mptr',2),
      writeOp('mptr','tm2',1)
    }
  end

  if h.eqAny(s,'hl','ix','iy') then
    generateI(g,o,fname,[[
      z->T=4;
      z->r.q=1;
    ]],unpack(ops))
  else
    generateI(g,o,fname,util.format([[
      uint8_t v=z->r.%s+%d;
      z->r.%s=v;
      %s;
      z->T=4;
      z->r.q=1;
    ]],s,d,s,flags))
  end
end

--inc
local function inc8(s,o,g)
  incdec8(s,o,g,'inc',1,[[
  _LOOKUP2
  
  z->r.f=(sz53cFlags[v] & 0xfe) | hAddFlags[l&0x7] | vAddFlags[l>>4] | (z->r.f & 0x1);
  ]])
end

--inc
local function dec8(s,o,g)
  incdec8(s,o,g,'dec',-1,[[
  _LOOKUP3
  
  z->r.f=(sz53cFlags[v] & 0xfe) | hSubFlags[l&0x7] | vSubFlags[l>>4] | 0x2 | (z->r.f & 0x1);
  ]])
end

for i,o in pairs(r8) do
  add8(o,0x80+i,inst,4,1)
  adc8(o,0x88+i,inst,4,1)
  sub8(o,0x90+i,inst,4,1)
  sbc8(o,0x98+i,inst,4,1)
  and8(o,0xa0+i,inst,4,1)
  or8(o,0xb0+i,inst,4,1)
  xor8(o,0xa8+i,inst,4,1)
  cp8(o,0xb8+i,inst,4,1)
  inc8(o,0x4+ls(i,3),inst,4,1)
  dec8(o,0x5+ls(i,3),inst,4,1)

  if h.eqAny(o,'h','l') then
    add8(r8ix[o],0x80+i,ddInst)
    add8(r8iy[o],0x80+i,fdInst)

    adc8(r8ix[o],0x88+i,ddInst)
    adc8(r8iy[o],0x88+i,fdInst)

    sub8(r8ix[o],0x90+i,ddInst)
    sub8(r8iy[o],0x90+i,fdInst)

    sbc8(r8ix[o],0x98+i,ddInst)
    sbc8(r8iy[o],0x98+i,fdInst)

    and8(r8ix[o],0xa0+i,ddInst)
    and8(r8iy[o],0xa0+i,fdInst)

    or8(r8ix[o],0xb0+i,ddInst)
    or8(r8iy[o],0xb0+i,fdInst)

    xor8(r8ix[o],0xa8+i,ddInst)
    xor8(r8iy[o],0xa8+i,fdInst)

    cp8(r8ix[o],0xb8+i,ddInst)
    cp8(r8iy[o],0xb8+i,fdInst)

    inc8(r8ix[o],0x4+ls(i,3),ddInst)
    inc8(r8iy[o],0x4+ls(i,3),fdInst)

    dec8(r8ix[o],0x5+ls(i,3),ddInst)
    dec8(r8iy[o],0x5+ls(i,3),fdInst)
  end
end

add8('nn',0xc6,inst,7,2)
add8('hl',0x86,inst,7,2)
add8('ix',0x86,ddInst,19,5)
add8('iy',0x86,fdInst,19,5)

adc8('nn',0xce,inst,7,2)
adc8('hl',0x8e,inst,7,2)
adc8('ix',0x8e,ddInst,19,5)
adc8('iy',0x8e,fdInst,19,5)

sub8('nn',0xd6,inst,7,2)
sub8('hl',0x96,inst,7,2)
sub8('ix',0x96,ddInst,19,5)
sub8('iy',0x96,fdInst,19,5)

sbc8('nn',0xde,inst,7,2)
sbc8('hl',0x9e,inst,7,2)
sbc8('ix',0x9e,ddInst,19,5)
sbc8('iy',0x9e,fdInst,19,5)

and8('nn',0xe6,inst,7,2)
and8('hl',0xa6,inst,7,2)
and8('ix',0xa6,ddInst,19,5)
and8('iy',0xa6,fdInst,19,5)

or8('nn',0xf6,inst,7,2)
or8('hl',0xb6,inst,7,2)
or8('ix',0xb6,ddInst,19,5)
or8('iy',0xb6,fdInst,19,5)

xor8('nn',0xee,inst,7,2)
xor8('hl',0xae,inst,7,2)
xor8('ix',0xae,ddInst,19,5)
xor8('iy',0xae,fdInst,19,5)

cp8('nn',0xfe,inst,7,2)
cp8('hl',0xbe,inst,7,2)
cp8('ix',0xbe,ddInst,19,5)
cp8('iy',0xbe,fdInst,19,5)

inc8('hl',0x34,inst,7,2)
inc8('ix',0x34,ddInst,19,5)
inc8('iy',0x34,fdInst,19,5)

dec8('hl',0x35,inst,7,2)
dec8('ix',0x35,ddInst,19,5)
dec8('iy',0x35,fdInst,19,5)

generateI(inst,0x27,'daa',[[
  uint8_t v=0;
  uint8_t c=z->r.f & 0x1;
  if((z->r.f & 0x10) || ((z->r.a&0xf)>0x9)) v=0x6;
  if((z->r.f & 0x1) || z->r.a>0x99) v|=0x60;
  if(z->r.a>0x99) c=0x1;

  if(z->r.f & 0x2)
  {
    uint16_t r=z->r.a-v;
    _LOOKUP

    z->r.f=sz53pcFlags[r&0xff] | hSubFlags[l&0x7] | 0x2 |c;
    z->r.a=(uint8_t)r;
  }
  else
  {
    uint16_t r=z->r.a+v;
    _LOOKUP

    z->r.f=sz53pcFlags[r&0xff] | hAddFlags[l&0x7] | c;
    z->r.a=(uint8_t)r;
  }

  z->r.q=1;
  z->T=4;
]])

generateI(inst,0x2f,'cpl',[[
  z->r.a^=0xff;

  z->r.f=(z->r.f & 0xd7) | (z->r.a & 0x28) | 0x12;

  z->r.q=1;
  z->T=4;
]])

generateI(edInst,0x44,'neg',[[
  uint8_t v=z->r.a;
  z->r.a=0;
  uint16_t r=z->r.a-v;
  _LOOKUP

  z->r.q=1;
  z->r.f=sz53cFlags[r&0x1ff] | hSubFlags[l&0x7] | vSubFlags[l>>4] | 0x2;
  z->r.a=r;
  z->T=4;
]])

generateI(inst,0x3f,'ccf',[[
  uint8_t c=z->r.f & 0x1;
  uint8_t nc=c ? 0 : 0x1;
  uint8_t v=z->r.q ? (z->r.a & 0x28) : ((z->r.f | z->r.a) & 0x28);
  z->r.f=(z->r.f & 0xc4) | v | (c<<4) | nc;

  z->r.q=1;
  z->T=4;
]])

generateI(inst,0x37,'scf',[[
  uint8_t v=z->r.q ? (z->r.a & 0x28) : ((z->r.f | z->r.a) & 0x28);
  z->r.f=(z->r.f & 0xc4) | v | 0x1;

  z->r.q=1;
  z->T=4;
]])

generateI(inst,0xf3,'di',[[
  z->r.iff=0; z->r.iff2=0;

  z->r.q=0;
  z->T=4;
]])

generateI(inst,0xfb,'ei',[[
  z->r.iff=1; z->r.iff2=1;
  z->r.q=0;
  //z->dispatch=nInst;
  z->T=4;
]],
  generateOp('eiOp',[[
    uint8_t c=z->con1(z,z->r.pc);
    uint8_t opc=z->get(z,z->r.pc++);

    z->r.r=((z->r.r+1) & 0x7f) | (z->r.r & 0x80);
    nInst[opc](z);
    z->T+=c;
  ]])
)

generateI(edInst,0x46,'im0',[[
  z->r.iMode=0;
  z->r.q=0;
  z->T=4;
]])

edInst[0x66]=edInst[0x46]
edInst[0x4e]=edInst[0x46]
edInst[0x6e]=edInst[0x46]

generateI(edInst,0x56,'im1',[[
  z->r.iMode=1;
  z->r.q=0;
  z->T=4;
]])

edInst[0x76]=edInst[0x56]

generateI(edInst,0x5e,'im2',[[
  z->r.iMode=2;
  z->r.q=0;
  z->T=4;
]])

edInst[0x7e]=edInst[0x5e]

--Undocumented
edInst[0x4c]=edInst[0x44]
edInst[0x54]=edInst[0x44]
edInst[0x5c]=edInst[0x44]
edInst[0x64]=edInst[0x44]
edInst[0x6c]=edInst[0x44]
edInst[0x74]=edInst[0x44]
edInst[0x7c]=edInst[0x44]

---------------------------
--16-Bit Arithmetic Group--
---------------------------

local function arithmetic16(d,s,o,g,name,oper)
  local name=name..'16_'..d..'_'..s

  generateI(g,o,name,util.format([[
uint16_t v=z->r.%s;
uint16_t o=z->r.%s;

%s

z->r.%s=r;
z->r.q=1;
z->T=4;
  ]],s,d,oper,d),
    cont2Op('ir',1),
    cont2Op('ir',1),
    cont2Op('ir',1),
    cont2Op('ir',1),
    cont2Op('ir',1),
    cont2Op('ir',1),
    cont2Op('ir',1)
  )
end

local function add16(d,s,o,g)
  arithmetic16(d,s,o,g,'add',util.format([[
    uint32_t r=o+v;
    z->r.mptr=o+1;
    _LOOKUP16ADD
    
    z->r.f=(z->r.f & 0xc4) | (sz53cFlags[(r&0x1ff00)>>8] & 0x29) | hAddFlags[l&0x7];
  ]]))
end

local function adc16(d,s,o,g)
  arithmetic16(d,s,o,g,'adc',util.format([[
    uint32_t r=o+v+(z->r.f & 0x1);
    z->r.mptr=o+1;
    _LOOKUP16
    
    z->r.f=(sz53cFlags[(r&0x1ff00)>>8] & 0xA9) | hAddFlags[l&0x7] | vAddFlags[l>>4] | (((uint16_t)r) ? 0 : 0x40);
  ]],d,d))
end

local function sbc16(d,s,o,g)
  arithmetic16(d,s,o,g,'sbc',util.format([[
    uint32_t r=z->r.%s-v-(z->r.f & 0x1);
    z->r.mptr=o+1;
    _LOOKUP16
    
    z->r.f=(sz53cFlags[(r&0x1ff00)>>8] & 0xa9)  | hSubFlags[l&0x7] | vSubFlags[l>>4] | (((uint16_t)r) ? 0x2 : 0x42);
  ]],d,d))
end

local function incdec16(d,i,o,g,name)
  local name=name..'16_'..d

  generateI(g,o,name,util.format([[
  z->r.%s+=%d;
  z->r.q=0;
  z->T=4;
]],d,i),
    cont2Op('ir',1),
    cont2Op('ir',1)
  )
end

local r16={[0]='bc','de','hl','sp'}

for k,v in pairs(r16) do
  add16('hl',v,ls(k,4)+0x9,inst)
  adc16('hl',v,ls(k,4)+0x4a,edInst)
  sbc16('hl',v,ls(k,4)+0x42,edInst)
  add16('ix',v=='hl' and 'ix' or v,ls(k,4)+0x9,ddInst)
  add16('iy',v=='hl' and 'iy' or v,ls(k,4)+0x9,fdInst)
  incdec16(v,1,ls(k,4)+0x3,inst,'inc')
  incdec16(v,-1,ls(k,4)+0xb,inst,'dec')
end


incdec16('ix',1,0x23,ddInst,'inc')
incdec16('iy',1,0x23,fdInst,'inc')

incdec16('ix',-1,0x2b,ddInst,'dec')
incdec16('iy',-1,0x2b,fdInst,'dec')

--------------------------
--Rotate and Shift Group--
--------------------------

generateI(inst,0x7,'rlca',[[
  uint16_t v=z->r.a<<1;
  z->r.a=v | (v>>8);
  z->r.f=(z->r.f & 0xc4) | (z->r.a & 0x28) | (v>>8);

  z->r.q=1;
  z->T=4;
]])

generateI(inst,0x17,'rla',[[
  uint16_t v=(z->r.a<<1) | (z->r.f & 0x1);
  z->r.a=v;
  z->r.f=(z->r.f & 0xc4) |  (z->r.a & 0x28) | (v>>8);
  
  z->r.q=1;
  z->T=4;
]])

generateI(inst,0x0f,'rrca',[[
  uint8_t c=z->r.a & 0x1;
  z->r.a=((z->r.a & 0x1)<<7) | (z->r.a>>1);
  z->r.f=(z->r.f & 0xc4) | (z->r.a & 0x28) | c;

  z->r.q=1;
  z->T=4;
]])

generateI(inst,0x1f,'rra',[[
  uint8_t c=(z->r.f & 0x1)<<7;
  uint8_t cc=z->r.a & 0x1;
  uint16_t v=(z->r.a>>1) | c;
  z->r.f=(z->r.f & 0xc4) | (v & 0x28) | cc;
  z->r.a=v;
   
  z->r.q=1; 
  z->T=4;
]])

local function shiftO(s,o,g,op,name,p,copy)
  if p==nil then p=true end
  --print('k',copy)
  if copy==nil then copy='' end
  
  local fname=name..'_'..s..copy
  --print(fname)
  if s=='hl' then
    local wps={}

    if p then
      wps[#wps+1]=cont1Op('hl',2)
      wps[#wps+1]=writeOp('hl','tm2',1)
    end

    if copy~='' then
      copy='z->r.'..copy..'=v;\n'
    end
  
    generateI(g,o,fname,[[
      z->T=4;
    ]],
      cont1Op('hl',2),
      readOp('tm2','hl',1),
      generateOp(fname..'Op',util.format([[
        %s
        %s
        z->T=1+z->con2(z,z->r.hl);
      ]],op,copy)),
      unpack(wps)
    )
  elseif h.eqAny(s,'ix','iy') then
    local wps={}

    if p then
      wps[#wps+1]=cont1iOp(s,2)
      wps[#wps+1]=writeIOp(s,'tm2',1)
    end

    if copy~='' then
      copy='z->r.'..copy..'=v;\n'
    end
  
    generateI(g,o,fname,[[
      z->T=3;
    ]],
      cont2Op('pc',1),
      cont2Op('pc',1),
      cont1iOp(s,2),
      readIOp('tm2',s,1),
      generateOp(fname..'Op',util.format([[
        %s
        %s
        z->T=1+z->con2(z,z->r.mptr);
      ]],op,copy)),
      unpack(wps)
    )
  else
    generateI(g,o,fname,util.format([[
      %s
      z->T=4;
    ]],op))
  end
end

function rlc(s,o,g,copy)
  local op
  if(h.eqAny(s,'hl','ix','iy')) then
    op=[[
  uint16_t v=(z->r.tm2<<1) | (z->r.tm2>>7);
  z->r.tm2=v;
  z->r.f=sz53pcFlags[v&0x1ff];
  z->r.q=1;
    ]]
  else
    op=util.format([[
  uint16_t v=(z->r.%s<<1) | (z->r.%s>>7);
  z->r.%s=v;
  z->r.f=sz53pcFlags[v&0x1ff];
  z->r.q=1;
]],s,s,s)
  end

  return shiftO(s,o,g,op,'rlc',nil,copy)
end

function rl(s,o,g,copy)
  local op
  if(h.eqAny(s,'hl','ix','iy')) then
    op=[[
  uint16_t v=(z->r.tm2<<1) | (z->r.f & 0x1);
  z->r.tm2=v;
  z->r.f=sz53pcFlags[v&0x1ff];
  z->r.q=1;
    ]]
  else
    op=util.format([[
  uint16_t v=(z->r.%s<<1) | (z->r.f & 0x1);
  z->r.%s=v;
  z->r.f=sz53pcFlags[v&0x1ff];
  z->r.q=1;
]],s,s,s)
  end

  return shiftO(s,o,g,op,'rl',nil,copy)
end

function rrc(s,o,g,copy)
  local op
  if(h.eqAny(s,'hl','ix','iy')) then
    op=[[
  uint16_t v=(z->r.tm2>>1) | ((z->r.tm2&0x1)<<7);
  z->r.tm2=v;
  z->r.f=sz53pcFlags[v&0xff] | (v>>7);
  z->r.q=1;
    ]]
  else
    op=util.format([[
  uint16_t v=(z->r.%s>>1) | ((z->r.%s & 0x1)<<7);
  z->r.%s=v;
  z->r.f=sz53pcFlags[v&0xff] | (v>>7);
  z->r.q=1;
]],s,s,s)
  end

  return shiftO(s,o,g,op,'rrc',nil,copy)
end

function rr(s,o,g,copy)
  local op
  if(h.eqAny(s,'hl','ix','iy')) then
    op=[[
  uint8_t m=z->r.tm2;
  uint16_t v=(m>>1) | ((z->r.f&0x1)<<7);
  z->r.tm2=v;
  z->r.f=sz53pcFlags[v&0xff] | (m&0x1);
  z->r.q=1;
    ]]
  else
    op=util.format([[
  uint8_t m=z->r.%s;
  uint16_t v=(m>>1) | ((z->r.f&0x1)<<7);
  z->r.%s=v;
  z->r.f=sz53pcFlags[v&0xff] | (m&0x1);
  z->r.q=1;
]],s,s)
  end

  return shiftO(s,o,g,op,'rr',nil,copy)
end

function sla(s,o,g,copy)
  local op
  if(h.eqAny(s,'hl','ix','iy')) then
    op=[[
  uint16_t v=(z->r.tm2<<1);
  z->r.tm2=v;
  z->r.f=sz53pcFlags[v];
  z->r.q=1;
    ]]
  else
    op=util.format([[
  uint16_t v=(z->r.%s<<1);
  z->r.%s=v;
  z->r.f=sz53pcFlags[v];
  z->r.q=1;
]],s,s,s)
  end

  return shiftO(s,o,g,op,'sla',nil,copy)
end

function sll(s,o,g,copy)
  local op
  if(h.eqAny(s,'hl','ix','iy')) then
    op=[[
  uint16_t v=(z->r.tm2<<1) | 0x1;
  z->r.tm2=v;
  z->r.f=sz53pcFlags[v];
  z->r.q=1;
    ]]
  else
    op=util.format([[
  uint16_t v=(z->r.%s<<1) | 0x1;
  z->r.%s=v;
  z->r.f=sz53pcFlags[v];
  z->r.q=1;
]],s,s,s)
  end

  return shiftO(s,o,g,op,'sll',nil,copy)
end

function sra(s,o,g,copy)
  local op
  if(h.eqAny(s,'hl','ix','iy')) then
    op=[[
  uint8_t m=z->r.tm2;
  uint16_t v=(m>>1) | (m&0x80);
  z->r.tm2=v;
  z->r.f=sz53pcFlags[v&0xff] | (m&0x1);
  z->r.q=1;
    ]]
  else
    op=util.format([[
  uint8_t m=z->r.%s;
  uint16_t v=(m>>1) | (m&0x80);
  z->r.%s=v;
  z->r.f=sz53pcFlags[v&0xff] | (m&0x1);
  z->r.q=1;
]],s,s)
  end

  return shiftO(s,o,g,op,'sra',nil,copy)
end

function srl(s,o,g,copy)
  local op
  if(h.eqAny(s,'hl','ix','iy')) then
    op=[[
  uint8_t m=z->r.tm2;
  uint16_t v=(m>>1);
  z->r.tm2=v;
  z->r.f=sz53pcFlags[v&0xff] | (m&0x1);
  z->r.q=1;
    ]]
  else
    op=util.format([[
  uint8_t m=z->r.%s;
  uint16_t v=(m>>1);
  z->r.%s=v;
  z->r.f=sz53pcFlags[v&0xff] | (m&0x1);
  z->r.q=1;
]],s,s)
  end

  return shiftO(s,o,g,op,'srl',nil,copy)
end

function bit(s,b,o,g,p)
  local op
  if(h.eqAny(s,'ix','iy')) then
    op=util.format([[
  uint8_t d=(z->r.%s+((int8_t)z->r.tm1))>>8;
  uint8_t v=z->r.tm2 & (0x1<<%d);
  z->r.f=(sz53cFlags[v] & 0x80) | (sz53cFlags[d] & 0x28) | ((v) ? 0x10 : 0x54) | (z->r.f & 0x1);
  z->r.q=1;
]],s,b,b)
  elseif s=='hl' then
    op=util.format([[
  uint8_t v=z->r.tm2 & (0x1<<%d);
  z->r.f=(sz53cFlags[v] & 0x80) | (sz53cFlags[z->r.mptrh] & 0x28) | ((v) ? 0x10 : 0x54) | (z->r.f & 0x1);
  z->r.q=1;
]],b)
  else
    op=util.format([[
  uint8_t v=z->r.%s & (0x1<<%d);
  z->r.f=(sz53cFlags[v] & 0x80) | (sz53cFlags[z->r.%s] & 0x28) | ((v) ? 0x10 : 0x54) | (z->r.f & 0x1);
  z->r.q=1;
]],s,b,s)
  end

  return shiftO(s,o,g,op,'bit_'..b,p,copy)
end

function set(s,b,o,g,p,copy)
  local op
  if(h.eqAny(s,'hl','ix','iy')) then
    op=util.format([[
  uint8_t v=z->r.tm2 | (0x1<<%d);
  z->r.tm2=v;
  z->r.q=0;
    ]],b)
  else
    op=util.format([[
  uint8_t v=z->r.%s | (0x1<<%d);
  z->r.%s=v;
  z->r.q=0;
]],s,b,s)
  end

  return shiftO(s,o,g,op,'set_'..b,p,copy)
end

function res(s,b,o,g,p,copy)
  local op
  if(h.eqAny(s,'hl','ix','iy')) then
    op=util.format([[
  uint8_t v=z->r.tm2 & (0xff ^ (0x1<<%d)); 
  z->r.tm2=v; 
  z->r.q=0;
    ]],b)
  else
    op=util.format([[
  uint8_t v=z->r.%s & (0xff ^ (0x1<<%d)); 
  z->r.%s=v;
  z->r.q=0;
]],s,b,s)
  end

  return shiftO(s,o,g,op,'res_'..b,nil,copy)
end

for i=0,7 do
  bit('hl',i,ls(i,3)+0x46,cbInst,false)
  bit('ix',i,ls(i,3)+0x46,ddcbInst,false)
  bit('iy',i,ls(i,3)+0x46,fdcbInst,false)

  res('hl',i,ls(i,3)+0x86,cbInst)
  res('ix',i,ls(i,3)+0x86,ddcbInst)
  res('iy',i,ls(i,3)+0x86,fdcbInst)

  set('hl',i,ls(i,3)+0xC6,cbInst)
  set('ix',i,ls(i,3)+0xC6,ddcbInst)
  set('iy',i,ls(i,3)+0xC6,fdcbInst)
end

for k,v in pairs(r8) do
  rlc(v,k,cbInst)
  rl(v,k+0x10,cbInst)
  rrc(v,k+0x8,cbInst)
  rr(v,k+0x18,cbInst)
  sla(v,k+0x20,cbInst)
  sll(v,k+0x30,cbInst) --Undocumented
  sra(v,k+0x28,cbInst)
  srl(v,k+0x38,cbInst)

  rlc('ix',k,ddcbInst,v)
  rlc('iy',k,fdcbInst,v)

  rl('ix',k+0x10,ddcbInst,v)
  rl('iy',k+0x10,fdcbInst,v)

  rrc('ix',k+0x8,ddcbInst,v)
  rrc('iy',k+0x8,fdcbInst,v)

  rr('ix',k+0x18,ddcbInst,v)
  rr('iy',k+0x18,fdcbInst,v)

  sla('ix',k+0x20,ddcbInst,v)
  sla('iy',k+0x20,fdcbInst,v)

  sll('ix',k+0x30,ddcbInst,v)
  sll('iy',k+0x30,fdcbInst,v)

  sra('ix',k+0x28,ddcbInst,v)
  sra('iy',k+0x28,fdcbInst,v)

  srl('ix',k+0x38,ddcbInst,v)
  srl('iy',k+0x38,fdcbInst,v)

  for i=0,7 do
    bit(v,i,ls(i,3)+k+0x40,cbInst,false)
    res(v,i,ls(i,3)+k+0x80,cbInst)
    set(v,i,ls(i,3)+k+0xC0,cbInst)

    res('ix',i,ls(i,3)+k+0x80,ddcbInst,true,v)
    res('iy',i,ls(i,3)+k+0x80,fdcbInst,true,v)

    set('ix',i,ls(i,3)+k+0xC0,ddcbInst,true,v)
    set('iy',i,ls(i,3)+k+0xC0,fdcbInst,true,v)

    ddcbInst[ls(i,3)+k+0x40]='bit_'..i..'_ix'
    fdcbInst[ls(i,3)+k+0x40]='bit_'..i..'_iy'
  end
end

rlc('hl',0x6,cbInst)
rlc('ix',0x6,ddcbInst)
rlc('iy',0x6,fdcbInst)

rl('hl',0x16,cbInst)
rl('ix',0x16,ddcbInst)
rl('iy',0x16,fdcbInst)

rrc('hl',0x0e,cbInst)
rrc('ix',0x0e,ddcbInst)
rrc('iy',0x0e,fdcbInst)

rr('hl',0x1e,cbInst)
rr('ix',0x1e,ddcbInst)
rr('iy',0x1e,fdcbInst)

sla('hl',0x26,cbInst)
sla('ix',0x26,ddcbInst)
sla('iy',0x26,fdcbInst)

sll('hl',0x36,cbInst)
sll('ix',0x36,ddcbInst)
sll('iy',0x36,fdcbInst)

sra('hl',0x2e,cbInst)
sra('ix',0x2e,ddcbInst)
sra('iy',0x2e,fdcbInst)

srl('hl',0x3e,cbInst)
srl('ix',0x3e,ddcbInst)
srl('iy',0x3e,fdcbInst)

generateI(edInst,0x6f,'rld',[[
  z->r.q=1;
  z->T=4;
]],
  cont1Op('hl',2),
  readOp('tm2','hl',1),
  generateOp('rldOp',[[
  uint8_t m=z->r.tm2;
  z->r.tm2=((z->r.a & 0xf) | (m<<4));
  z->r.a=(z->r.a & 0xf0) | (m>>4);
  z->r.f=sz53pcFlags[z->r.a] | (z->r.f & 0x1);
  z->r.mptr=z->r.hl+1;
  z->T=1+z->con2(z,z->r.hl);
  ]]),
  cont2Op('hl',1),
  cont2Op('hl',1),
  cont2Op('hl',1),
  cont1Op('hl',2),
  writeOp('hl','tm2',1)
)

generateI(edInst,0x67,'rrd',[[
  z->r.q=1;
  z->T=4;
]],
  cont1Op('hl',2),
  readOp('tm2','hl',1),
  generateOp('rrdOp',[[
  uint8_t m=z->r.tm2;
  z->r.tm2=((z->r.a<<4) | (m>>4));
  z->r.a=(z->r.a & 0xf0) | (m&0xf);

  z->r.f=sz53pcFlags[z->r.a] | (z->r.f & 0x1);
  z->r.mptr=z->r.hl+1;
  z->T=1+z->con2(z,z->r.hl);
  ]]),
  cont2Op('hl',1),
  cont2Op('hl',1),
  cont2Op('hl',1),
  cont1Op('hl',2),
  writeOp('hl','tm2',1)
)

------------------------------------
-- Jump group ----------------------
------------------------------------

generateOp('rettOp',[[
  z->r.pch=z->get(z,z->r.sp++);
  //printf("ret:%.x\n",z->r.pc);
  z->r.mptr=z->r.pc;
  z->T=1;
]])

generateOp('callccOp',[[
  //printf("call: %.x\n",z->r.pc);
  z->r.pc=z->r.mptr;
  z->T=1;
]])

generateI(inst,0xc3,'jmp',[[
  z->r.q=0;
  z->T=4;
]],
  cont1Op('pc',2),
  readIncOp('mptrl','pc',1),
  cont1Op('pc',1),
  readIncOp('mptrh','pc',1),
  'callccOp'
)

local function jmpc(o,c,name)
  generateI(inst,o,name,[[
    z->r.q=0;
    z->T=4;
  ]],
    cont1Op('pc',2),
    readIncOp('mptrl','pc',1),
    cont1Op('pc',2),
    generateOp(name..'Op',util.format([[
      z->r.mptrh=z->get(z,z->r.pc++);
      %s
        z->r.pc=z->r.mptr;

      z->T=1;
    ]],c))
  )
end

jmpc(0xc2+ls(0,3),'if(!(z->r.f & 0x40))','jmpnz')
jmpc(0xc2+ls(1,3),'if((z->r.f & 0x40))','jmpz')
jmpc(0xc2+ls(2,3),'if(!(z->r.f & 0x01))','jmpnc')
jmpc(0xc2+ls(3,3),'if((z->r.f & 0x01))','jmpc')
jmpc(0xc2+ls(4,3),'if(!(z->r.f & 0x04))','jmppo')
jmpc(0xc2+ls(5,3),'if((z->r.f & 0x04))','jmppe')
jmpc(0xc2+ls(6,3),'if(!(z->r.f & 0x80))','jmpp')
jmpc(0xc2+ls(7,3),'if((z->r.f & 0x80))','jmpm')

generateI(inst,0x18,'jr',[[
  z->r.q=0;
  z->T=4;
]],
  cont1Op('pc',2),
  readIncOp('tm1','pc',1),
  generateOp('jrOp',[[
    z->r.pc+=(int8_t)z->r.tm1;
    z->r.mptr=z->r.pc;   
    z->T=1+z->con2(z,z->r.pc);
  ]]),
  cont2Op('pc',1),
  cont2Op('pc',1),
  cont2Op('pc',1),
  cont2Op('pc',1)
)

local function jrc(o,c,name)
  generateI2(inst,o,name,util.format([[
    %s
      z->uops=%s_uops2;
    else
      z->uops=%s_uops1;

    z->r.q=0;
    z->T=4;
  ]],c,name,name),{
    cont1Op('pc',2),
    readIncOp('tm1','pc',1),
  },
  {
    generateOp(name..'Op',[[
  z->r.pc+=(int8_t)z->r.tm1;
  z->r.mptr=z->r.pc;
  z->T=1+z->con2(z,z->r.pc);
    ]]),
    cont2Op('pc',1),
    cont2Op('pc',1),
    cont2Op('pc',1),
    cont2Op('pc',1),
  })
end

jrc(0x20,'if(!(z->r.f & 0x40))','jrnz')
jrc(0x28,'if((z->r.f & 0x40))','jrz')
jrc(0x30,'if(!(z->r.f & 0x01))','jrnc')
jrc(0x38,'if((z->r.f & 0x01))','jrc')

local function jmpi(s,o,g)
  local name='jmpi_'..s

  generateI(g,o,name,util.format([[
  z->r.pc=z->r.%s;
  z->r.q=0;
  z->T=4;   
  ]],s))
end

jmpi('hl',0xe9,inst)
jmpi('ix',0xe9,ddInst)
jmpi('iy',0xe9,fdInst)

generateI2(inst,0x10,'djnz',[[
  z->r.b--;

  if(z->r.b)
    z->uops=djnz_uops2;
  else
    z->uops=djnz_uops1;

  z->T=4;
]],{
  cont2Op('ir',1),
  cont1Op('pc',2),
  readIncOp('tm1','pc',1),
},{
  generateOp('djnzOp',[[
    z->r.aux=z->r.pc;
    z->r.pc+=(int8_t)z->r.tm1;
    z->r.mptr=z->r.pc;
    z->T=1+z->con2(z,z->r.aux);
  ]]),
  cont2Op('aux',1),
  cont2Op('aux',1),
  cont2Op('aux',1),
  cont2Op('aux',1)
})

generateI(inst,0xcd,'call',[[
  z->r.q=0;
  z->T=4;
]],
  cont1Op('pc',2),
  readIncOp('mptrl','pc',1),
  cont1Op('pc',2),
  readIncOp('mptrh','pc',1),
  generateOp('callOp',[[
      z->r.aux=z->r.pc;
      z->r.tm=z->r.pc;
      z->r.pc=z->r.mptr;
      z->T=1+z->con2(z,z->r.aux);
    ]]),
  cont1DecOp('sp',2),
  writeDecOp('sp','tm2',1),
  cont1DecOp('sp',2),
  writeDecOp('sp','tm1',1)
)

local function callc(o,c,name)
  generateI2(inst,o,name,util.format([[
    %s
      z->uops=%s_uops2;
    else
      z->uops=%s_uops1;

    z->r.q=0;
    z->T=4;
  ]],c,name,name),{
    cont1Op('pc',2),
    readIncOp('mptrl','pc',1),
    cont1Op('pc',2),
    readIncOp('mptrh','pc',1)
  },{
    generateOp(name..'Op',[[
      z->r.tm=z->r.pc;
      z->r.pc=z->r.mptr;
      z->T=1+z->con2(z,z->r.tm);
    ]]),
    cont1DecOp('sp',2),
    writeDecOp('sp','tm2',1),
    cont1DecOp('sp',2),
    writeDecOp('sp','tm1',1)
  })
end

callc(0xc4+ls(0,3),'if(!(z->r.f & 0x40))','callnz')
callc(0xc4+ls(1,3),'if((z->r.f & 0x40))','callz')
callc(0xc4+ls(2,3),'if(!(z->r.f & 0x01))','callnc')
callc(0xc4+ls(3,3),'if((z->r.f & 0x01))','callc')
callc(0xc4+ls(4,3),'if(!(z->r.f & 0x04))','callpo')
callc(0xc4+ls(5,3),'if((z->r.f & 0x04))','callpe')
callc(0xc4+ls(6,3),'if(!(z->r.f & 0x80))','callp')
callc(0xc4+ls(7,3),'if((z->r.f & 0x80))','callm')

generateI(inst,0xc9,'ret',[[
  z->r.q=0;
  z->T=4;
]],
  cont1Op('sp',2),
  readIncOp(low['pc'],'sp',1),
  cont1Op('sp',2),
  'rettOp'
)


local function retc(o,c,name)
  generateI2(inst,o,name,util.format([[
    %s
      z->uops=%s_uops2;
    else
      z->uops=%s_uops1;

    z->r.q=0;
    z->T=4;
  ]],c,name,name),
  {
    cont2Op('ir',1),
  }
  ,
  {
    --cont2Op('ir',1),
    cont1Op('sp',2),
    readIncOp(low['pc'],'sp',1),
    cont1Op('sp',2),
    'rettOp'
  })
end

retc(0xc0+ls(0,3),'if(!(z->r.f & 0x40))','retnz')
retc(0xc0+ls(1,3),'if((z->r.f & 0x40))','retz')
retc(0xc0+ls(2,3),'if(!(z->r.f & 0x01))','retnc')
retc(0xc0+ls(3,3),'if((z->r.f & 0x01))','retc')
retc(0xc0+ls(4,3),'if(!(z->r.f & 0x04))','retpo')
retc(0xc0+ls(5,3),'if((z->r.f & 0x04))','retpe')
retc(0xc0+ls(6,3),'if(!(z->r.f & 0x80))','retp')
retc(0xc0+ls(7,3),'if((z->r.f & 0x80))','retm')

-- *Todo: interrepcion terminada.
--reti
edInst[0x4d]=inst[0xc9]

generateI(edInst,0x45,'retn',[[
  z->r.iff=z->r.iff2;
  z->r.q=0;
  z->T=4;
]],
  cont1Op('sp',2),
  readIncOp(low.pc,'sp',1),
  cont1Op('sp',2),
  'rettOp'
)

--undocumented
edInst[0x55]='retn'
edInst[0x5D]='retn'
edInst[0x65]='retn'
edInst[0x6D]='retn'
edInst[0x75]='retn'
edInst[0x7D]='retn'

local function rst(o)
  local s=band(o,0x38)

  local name='rst_'..s

  generateI(inst,o,name,util.format([[
    z->r.tm=z->r.pc;
    z->r.mptr=z->r.pc=%d;
    z->r.q=0;
    z->T=4;
  ]],s),
    cont2Op('ir',1),
    cont1DecOp('sp',2),
    writeDecOp('sp','tm2',1),
    cont1DecOp('sp',2),
    writeDecOp('sp','tm1',1)
  )
end

for i=0,0x38,8 do
  rst(i+0xc7)
end

------------------------------------
-- I/O group -----------------------
------------------------------------

generateI(inst,0xdb,'in_a',[[
  z->r.tm2=z->r.a;
  z->r.q=0;
  z->T=4;
]],
  cont1Op('pc',2),
  readIncOp('tm1','pc',1),
  generateOp('in_aOp',[[
    z->r.tm=(z->r.a<<8) | z->r.tm1;
    z->r.mptr=z->r.tm+1;
    uint32_t c=z->conIO(z,z->r.tm);
    z->T=2+c;
  ]]),
  inOp('a','tm',2)
)

local function inr(s,o)
  local name='inr'..s

  generateI(edInst,o,name,[[
    z->r.q=1;
    z->T=4;
  ]],
    contIOOp('bc',2),
    generateOp(name..'Op',util.format([[
      z->r.%s=z->in(z,z->r.bc);
      z->r.f=(z->r.f & 0x1) | (sz53pcFlags[z->r.%s] & 0xec);
      z->r.mptr=z->r.bc+1;
      z->T=2;
    ]],s,s))
  )
end

for k,v in pairs(r8) do
  inr(v,ls(k,3)+0x40)
end 

inr('tm1',0x70) -- undocumented

generateI(edInst,0xa2,'ini',[[
  z->r.q=1;
  z->T=4;
]],
  cont2Op('ir',1),
  contIOOp('bc',2),
  inOp('tm1','bc',2),
  cont1Op('hl',1),
  generateOp('iniOp',[[
  z->r.mptr=z->r.bc+1;
  z->r.b--;
  uint8_t c=z->r.c+1;
  uint8_t h=((z->r.tm1+c)>255)?0x11:0x0;
  z->r.f=(sz53cFlags[z->r.b] & 0xE8) | ((z->r.tm1 & 0x80) >> 6) | h | (sz53pcFlags[((z->r.tm1+c) & 0x7) ^ z->r.b] & 0x4);   
  z->T=1;
  ]]),
  writeIncOp('hl','tm1',1)
)

generateI2a(edInst,0xb2,'inir',[[
  z->r.aux=z->r.hl;
  z->uops=inir_uops1;
  z->r.q=1;
  z->T=4;
]],{
  cont2Op('ir',1),
  contIOOp('bc',2),
  inOp('tm1','bc',2),
  cont1Op('hl',2),
  generateOp('inirOp',[[
    z->set(z,z->r.hl++,z->r.tm1);

    z->r.mptr=z->r.bc+1;
  z->r.b--;
  uint8_t c=z->r.c+1;
  uint8_t h=((z->r.tm1+c)>255)?0x11:0x0;
  z->r.f=(sz53cFlags[z->r.b] & 0xE8) | ((z->r.tm1 & 0x80) >> 6) | h | (sz53pcFlags[((z->r.tm1+c) & 0x7) ^ z->r.b] & 0x4);

  if(z->r.b)
  {
    z->r.pc-=2;
    z->uops=inir_uops2;    
  }

  z->T=1;
  ]])
},{
  cont2Op('aux',1),
  cont2Op('aux',1),
  cont2Op('aux',1),
  cont2Op('aux',1),
  cont2Op('aux',1)
})
-----

generateI(edInst,0xaa,'ind',[[
  z->r.q=1;
  z->T=4;
]],
  cont2Op('ir',1),
  contIOOp('bc',2),
  inOp('tm1','bc',2),
  cont1Op('hl',2),
  generateOp('indOp',[[
  z->set(z,z->r.hl--,z->r.tm1);
  z->r.mptr=z->r.bc-1;
  z->r.b--;
  
  uint8_t c=z->r.c-1;
  uint8_t h=((z->r.tm1+c)>255)?0x11:0x0;
  z->r.f=(sz53cFlags[z->r.b] & 0xE8) | ((z->r.tm1 & 0x80) >> 6) | h | (sz53pcFlags[((z->r.tm1+c) & 0x7) ^ z->r.b] & 0x4);   
  z->T=1;
  ]])
  
)

generateI2a(edInst,0xba,'indr',[[
  z->r.aux=z->r.hl;
  z->uops=indr_uops1;
  z->r.q=1;
  z->T=4;
]],{
  cont2Op('ir',1),
  contIOOp('bc',2),
  inOp('tm1','bc',2),
  cont1Op('hl',2),
  generateOp('indrOp',[[
    z->set(z,z->r.hl--,z->r.tm1);

    z->r.mptr=z->r.bc-1;
  z->r.b--;
  
  uint8_t c=z->r.c-1;
  uint8_t h=((z->r.tm1+c)>255)?0x11:0x0;
  z->r.f=(sz53cFlags[z->r.b] & 0xE8) | ((z->r.tm1 & 0x80) >> 6) | h | (sz53pcFlags[((z->r.tm1+c) & 0x7) ^ z->r.b] & 0x4);

  if(z->r.b)
  {
    z->r.pc-=2;
    z->uops=indr_uops2;    
  }

  z->T=1;
  ]])
},{
  cont2Op('aux',1),
  cont2Op('aux',1),
  cont2Op('aux',1),
  cont2Op('aux',1),
  cont2Op('aux',1)
})

generateI(inst,0xd3,'outa',[[
  z->r.tm2=z->r.a;
  z->r.q=0;
  z->T=4;
]],
  cont1Op('pc',2),
  generateOp('outaOp',[[
    z->r.tm1=z->get(z,z->r.pc++);
    z->r.tm=(z->r.a<<8) | z->r.tm1;
    z->r.mptr=(z->r.a<<8) | ((z->r.tm1+1) & 0xff);
    z->T=1;
  ]]),
  contIOOp('tm',2),
  outOp('tm','a',2)
)

local function outr(s,o)
  local name='outr_'..s

  generateI(edInst,o,name,[[
    z->r.q=0;
    z->r.mptr=z->r.bc+1;
    z->T=4;  
  ]],
    contIOOp('bc',2),
    outOp('bc',s,2)
  )
end

generateI(edInst,0x71,'out0',[[
  z->r.tm1=0;
  z->r.q=0;
  z->r.mptr=z->r.bc+1;
  z->T=4;  
]],
  contIOOp('bc',2),
  outOp('bc','tm1',2)
)

for k,v in pairs(r8) do
  outr(v,ls(k,3)+0x41)
end 

generateI(edInst,0xa3,'outi',[[
  z->r.b--;
  z->r.mptr=z->r.bc+1;
  z->r.q=1;
  z->T=4;
]],
  cont2Op('ir',1),
  cont1Op('hl',2),
  readIncOp('tm1','hl',1),
  contIOOp('bc',2),
  generateOp('outiOp',[[
    z->out(z,z->r.bc,z->r.tm1);
    uint8_t h=((z->r.tm1+z->r.l)>255)?0x11:0x0;
    z->r.f=(sz53cFlags[z->r.b] & 0xE8) | ((z->r.tm1 & 0x80) >> 6) | h | (sz53pcFlags[((z->r.tm1+z->r.l) & 0x7) ^ z->r.b] & 0x4);
    z->T=2;
  ]])
)

generateI2a(edInst,0xb3,'otir',[[
  z->uops=otir_uops1;
  z->r.aux=z->r.bc;
  z->r.b--;
  z->r.mptr=z->r.bc+1;  
  z->r.q=1;
  z->T=4;
]],{
  cont2Op('ir',1),
  cont1Op('hl',2),
  readIncOp('tm1','hl',1),
  contIOOp('bc',2),
  generateOp('otirOp',[[
    z->out(z,z->r.bc,z->r.tm1);

    if(z->r.b)
    {
      z->r.pc-=2;
      z->uops=otir_uops2;
    }
    uint8_t h=((z->r.tm1+z->r.l)>255)?0x11:0x0;
    z->r.f=(sz53cFlags[z->r.b] & 0xE8) | ((z->r.tm1 & 0x80) >> 6) | h | (sz53pcFlags[((z->r.tm1+z->r.l) & 0x7) ^ z->r.b] & 0x4);
    z->T=2;
  ]])
},{
  cont2Op('aux',1),
  cont2Op('aux',1),
  cont2Op('aux',1),
  cont2Op('aux',1),
  cont2Op('aux',1),
})

generateI(edInst,0xab,'outd',[[
  z->r.b--;
  z->r.mptr=z->r.bc-1;
  z->r.q=1;
  z->T=4;
]],
  cont2Op('ir',1),
  cont1Op('hl',2),
  readOp('tm1','hl',1),
  contIOOp('bc',2),
  generateOp('outdOp',[[
    z->out(z,z->r.bc,z->r.tm1);
    z->r.hl--;
  uint8_t h=((z->r.tm1+z->r.l)>255)?0x11:0x0;
  z->r.f=(sz53cFlags[z->r.b] & 0xE8) | ((z->r.tm1 & 0x80) >> 6) | h | (sz53pcFlags[((z->r.tm1+z->r.l) & 0x7) ^ z->r.b] & 0x4);
  z->T=2;
  ]])
)

generateI2a(edInst,0xbb,'otdr',[[
  z->uops=otdr_uops1;
  z->r.aux=z->r.bc;
  z->r.b--;
  z->r.mptr=z->r.bc-1;  
  z->r.q=1;
  z->T=4;
]],{
  cont2Op('ir',1),
  cont1Op('hl',2),
  readOp('tm1','hl',1),
  contIOOp('bc',2),
  generateOp('otdrOp',[[
    z->out(z,z->r.bc,z->r.tm1);
    z->r.hl--;
    if(z->r.b)
    {
      z->r.pc-=2;
      z->uops=otdr_uops2;
    }
    uint8_t h=((z->r.tm1+z->r.l)>255)?0x11:0x0;
    z->r.f=(sz53cFlags[z->r.b] & 0xE8) | ((z->r.tm1 & 0x80) >> 6) | h | (sz53pcFlags[((z->r.tm1+z->r.l) & 0x7) ^ z->r.b] & 0x4);
    z->T=2;
  ]])
},{
  cont2Op('aux',1),
  cont2Op('aux',1),
  cont2Op('aux',1),
  cont2Op('aux',1),
  cont2Op('aux',1),
})

-- FIXME

generateI({},0,'z80_nmi',[[
  z->r.tm=z->r.pc;
  z->r.pc=z->r.mptr=0x0066;
  z->T=5;
]],
  cont1Op('sp',2),
  writeDecOp('sp','tm2',1),
  cont1Op('sp',2),
  writeDecOp('sp','tm1',1))


generateI({},0,'z80_i0',[[
  z->r.tm1=z->busInt(z);
  z->T=2;
]],
  generateOp('z80_i0Op',[[
    uint8_t c=z->con1(z,z->r.pc);
    nInst[z->r.tm1](z);
    z->T+=c;
  ]])
)

generateI({},0,'z80_i1',[[
  z->T=2;
]],
  generateOp('z80_i1Op',[[
    uint8_t c=z->con1(z,z->r.pc);
    nInst[0xff](z);
    z->T+=c;
  ]])
)

generateI({},0,'z80_i2',[[
  z->r.tm1=z->busInt(z);
  z->r.tm2=z->r.i;
  z->T=7;
]],
  cont1Op('sp',2),
  writeDecOp('sp','pch',1),
  cont1Op('sp',2),
  writeDecOp('sp','pcl',1),
  cont1Op('tm',2),
  readIncOp('pcl','tm',1),
  cont1Op('tm',2),
  generateOp('z80_i2Op',[[
    z->r.pch=z->get(z,z->r.tm);
    z->r.mptr=z->r.pc;
    z->T=1;
  ]])
)


------------------------------------
-- Code generation -----------------
------------------------------------

--Instruction init
lines[#lines+1]=[[
void z80_init()
{
  //Normal opcodes]]

for i=0,0xff do
  lines[#lines+1]=util.format('  nInst[0x%.2x]=%s;',i,inst[i] and inst[i] or inst[0])
end

lines[#lines+1]=[[

  //0xcb opcodes
]]

for i=0,0xff do
  lines[#lines+1]=util.format('  cbInst[0x%.2x]=%s;',i,cbInst[i] and cbInst[i] or inst[0])
end


lines[#lines+1]=[[

  //0xdd opcodes
]]

for i=0,0xff do
  lines[#lines+1]=util.format('  ddInst[0x%.2x]=%s;',i,ddInst[i] and ddInst[i] or inst[i])
end

lines[#lines+1]=[[

  //0xddcb opcodes
]]

for i=0,0xff do
  lines[#lines+1]=util.format('  ddcbInst[0x%.2x]=%s;',i,ddcbInst[i] and ddcbInst[i] or inst[0])
end


lines[#lines+1]=[[

  //0xed opcodes
]]

for i=0,0xff do
  lines[#lines+1]=util.format('  edInst[0x%.2x]=%s;',i,edInst[i] and edInst[i] or inst[0])
end

lines[#lines+1]=[[

  //0xfd opcodes
]]

for i=0,0xff do
  lines[#lines+1]=util.format('  fdInst[0x%.2x]=%s;',i,fdInst[i] and fdInst[i] or inst[i])
end

lines[#lines+1]=[[

  //0xfdcb opcodes
]]

for i=0,0xff do
  lines[#lines+1]=util.format('  fdcbInst[0x%.2x]=%s;',i,fdcbInst[i] and fdcbInst[i] or inst[0])
end

lines[#lines+1]='}'

file.writeLines(filename..'uops.h',headerText)
--file.writeLines(filename..'uops.c',sourceText)
lines[#lines+1]=table.concat(sourceText,'\n')
file.writeLines(filename..'.c',lines)
