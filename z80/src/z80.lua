--[[
Copyright (c) 2013 Juan Carlos González Amestoy

Permission is hereby granted, free of charge, to any person obtaining a copy
of this software and associated documentation files (the "Software"), to deal
in the Software without restriction, including without limitation the rights
to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
copies of the Software, and to permit persons to whom the Software is
furnished to do so, subject to the following conditions:

The above copyright notice and this permission notice shall be included in
all copies or substantial portions of the Software.

THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN
THE SOFTWARE.
--]]

--[[
IO ops documentation

inc-i/o-w-r

------------------------------------------------------------
-(8bits)T|(8bits)offsetDest|(8)bitsOffsetSource|(8bitsOper)-
------------------------------------------------------------
]]
COMPILING=true

local copyright=[[
/*
Copyright (c) 2013 Juan Carlos González Amestoy

Permission is hereby granted, free of charge, to any person obtaining a copy
of this software and associated documentation files (the "Software"), to deal
in the Software without restriction, including without limitation the rights
to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
copies of the Software, and to permit persons to whom the Software is
furnished to do so, subject to the following conditions:

The above copyright notice and this permission notice shall be included in
all copies or substantial portions of the Software.

THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN
THE SOFTWARE.
*/

//Autogenerated by src/z80.lua don't touch.

#include "z80.h"

]]

local h=require('h')
local file=require('h.io.file')
local util=require('h.text.util')
local filename=arg[1]
local bit=require('bit')
local z80c=require('z80.z80c')
local ffi=require('ffi')

local band,bor,bxor,rs,ls=bit.band,bit.bor,bit.bxor,bit.rshift,bit.lshift
local lines,inst,ddInst,fdInst,edInst,cbInst,ddcbInst,fdcbInst={},{},{},{},{},{},{},{}

local low={
  bc='c',
  de='e',
  hl='l',
  af='f',
  sp='spl',
  ix='ixl',
  iy='iyl',
  pc='pcl',
  tm='tm1',
  aux='auxl'
}

local high={
  bc='b',
  de='d',
  hl='h',
  af='a',
  sp='sph',
  ix='ixh',
  iy='iyh',
  pc='pch',
  tm='tm2',
  aux='auxh'
}

local function readI(s,d,i,T,c)
  local con=c and 0x40 or 0;

  local o=T+ls(ffi.offsetof('regs',d),8)+ls(ffi.offsetof('regs',s),16)+ls(0x9+con,24)

  return util.format('z->o[%s].OC=0x%.8x;',i,o)
end

local function read(s,d,i,T,c)
  local con=c and 0x40 or 0

  local o=T+ls(ffi.offsetof('regs',d),8)+ls(ffi.offsetof('regs',s),16)+ls(0x1+con,24)

  return util.format('z->o[%s].OC=0x%.8x;',i,o)
end

local function write(s,d,i,T,c)
  local con=c and 0x40 or 0
  
  local o=T+ls(ffi.offsetof('regs',d),8)+ls(ffi.offsetof('regs',s),16)+ls(0x2+con,24)

  return util.format('z->o[%s].OC=0x%.8x;',i,o)
end

local function writeI(s,d,i,T,c)
  local con=c and 0x40 or 0

  local o=T+ls(ffi.offsetof('regs',d),8)+ls(ffi.offsetof('regs',s),16)+ls(0xa+con,24)

  return util.format('z->o[%s].OC=0x%.8x;',i,o)
end

local function writeD(s,d,i,T,c)
  local con=c and 0x40 or 0

  local o=T+ls(ffi.offsetof('regs',d),8)+ls(ffi.offsetof('regs',s),16)+ls(0x12+con,24)

  return util.format('z->o[%s].OC=0x%.8x;',i,o)
end

local function writeDc(s,d,i,T,c)
  local con=c and 0x40 or 0

  local o=T+ls(ffi.offsetof('regs',d),8)+ls(ffi.offsetof('regs',s),16)+ls(0x22+con,24)

  return util.format('z->o[%s].OC=0x%.8x;',i,o)
end

local function readD(s,d,i,T,c)
  local con=c and 0x40 or 0

  local o=T+ls(ffi.offsetof('regs',d),8)+ls(ffi.offsetof('regs',s),16)+ls(0x11+con,24)

  return util.format('z->o[%s].OC=0x%.8x;',i,o)
end

local function readDc(s,d,i,T,c)
  local con=c and 0x40 or 0

  local o=T+ls(ffi.offsetof('regs',d),8)+ls(ffi.offsetof('regs',s),16)+ls(0x21+con,24)

  return util.format('z->o[%s].OC=0x%.8x;',i,o)
end

local function inPort(s,d,i,T,c)
  local con=c and 0x40 or 0

  local o=T+ls(ffi.offsetof('regs',d),8)+ls(ffi.offsetof('regs',s),16)+ls(0x5+con,24)

  return util.format('z->o[%s].OC=0x%.8x;',i,o)
end

local function outPort(s,d,i,T,c)
  local con=c and 0x40 or 0

  local o=T+ls(ffi.offsetof('regs',d),8)+ls(ffi.offsetof('regs',s),16)+ls(0x6+con,24)

  return util.format('z->o[%s].OC=0x%.8x;',i,o)
end

local function exec(name,i,T,c,s)
  local con=c and 0x40 or 0;
  local ss=s and ffi.offsetof('regs',s) or 0;

  return util.format('z->exec=%s; z->o[%s].OC=0x%.8x;',name,i,T+ls(ss,16)+ls(0x3+con,24))
end

local function execD(name,i,T,c,s)
  local con=c and 0x40 or 0;
  local ss=s and ffi.offsetof('regs',s) or 0;

  return util.format('z->exec=%s; z->o[%s].OC=0x%.8x;',name,i,T+ls(ss,16)+ls(0x13+con,24))
end

local function con(s,i,T)
  local o=T+ls(ffi.offsetof('regs',s),16)+ls(0x40,24)

  return util.format('z->o[%s].OC=0x%.8x;',i,o)
end

lines[#lines+1]=copyright

lines[#lines+1]=[[
#define _LOOKUP uint8_t l=((z->r.a&0x88)>>3) | ((v & 0x88)>>2) | ((r&0x88)>>1);
#define _LOOKUP2 uint8_t l=((((uint8_t)(v-1))&0x88)>>3) | ((v&0x88)>>1);
#define _LOOKUP3 uint8_t l=((((uint8_t)(v+1))&0x88)>>3) | ((v&0x88)>>1);
#define _LOOKUP16 uint8_t l=((o&0x8800)>>11) | ((v & 0x8800)>>10) | ((r&0x8800)>>9);
#define _LOOKUP16ADD uint8_t l=((o&0x0800)>>11) | ((v & 0x0800)>>10) | ((r&0x0800)>>9);

uint8_t sz53cFlags[0x200]={]]
lines[#lines+1]=''
for v=0,0x1ff do
  --local v=i+j
  local f=band(v,0xA8)
  if band(v,0x100)~=0 then f=bor(f,0x1) end
  if band(v,0xff)==0 then f=bor(f,0x40) end --Z
  lines[#lines]=lines[#lines]..util.format("0x%.2x,",f)
end
lines[#lines+1]=[[
};]]

lines[#lines+1]=[[
uint8_t sz53pcFlags[0x200]={]]
lines[#lines+1]=''
for v=0,0x1ff do
  --local v=i+j
  local f=band(v,0xA8)
  local j,p=band(v,0xff),0
  for k=0,7 do 
    p=bxor(p,band(j,1))
    j=rs(j,1)
  end
  if p==0 then f=bor(f,0x4) end
  if band(v,0x100)~=0 then f=bor(f,0x1) end
  if band(v,0xff)==0 then f=bor(f,0x40) end --Z
  lines[#lines]=lines[#lines]..util.format("0x%.2x,",f)
end
lines[#lines+1]=[[
};]]

lines[#lines+1]=[[
const uint8_t hAddFlags[]={
  0,0x10,0x10,0x10,0,0,0,0x10
};

const uint8_t hSubFlags[]={
  0,0,0x10,0,0x10,0,0x10,0x10
};

const uint8_t vAddFlags[]={
  0,0,0,0x4,0x4,0,0,0
};

const uint8_t vSubFlags[]={
  0,0x4,0,0,0,0,0x4,0
};
]]

local function prefix(o)
  lines[#lines+1]=util.format([[
void prefix%x(z80* z)
{
  z->dispatch=%xInst;
  z->T=4;
}]],o,o)

  inst[o]=util.format('prefix%x',o)
  ddInst[o]=inst[o]
  fdInst[o]=inst[o]
end

local function sprefix(o)
  lines[#lines+1]=util.format([[
void prefix%x(z80* z)
{
  z->dispatch=%xInst;
  z->T=4;
}]],o,o)

  inst[o]=util.format('prefix%x',o)
end

local function sprefix2(o,t,g)
  lines[#lines+1]=util.format([[
void sprefix2_%s(z80* z)
{
  %s
  z->dispatch=%s;
  z->T=4;
}]],t,readI('pc','tm1',0,3,true),t)

  g[o]=util.format('sprefix2_%s',t)
end

prefix(0xdd)
prefix(0xfd)

sprefix(0xed)
sprefix(0xcb)

sprefix2(0xcb,'ddcbInst',ddInst)
sprefix2(0xcb,'fdcbInst',fdInst)

lines[#lines+1]=util.format([[
void nop(z80* z)
{
  z->r.q=0;
  z->T=4;  
}]])
inst[0x00]='nop'

lines[#lines+1]=util.format([[
void halt(z80* z)
{
  z->r.q=0;
  z->flags=z80HALTED;
  z->T=4;
}]])
inst[0x76]='halt'

--ld 8bit group

-- ld r,r (ld a,b)
local function loadr(d,s,o)
  lines[#lines+1]=util.format([[
void ldr_%s%s(z80* z)
{
  z->r.q=0;
  z->r.%s=z->r.%s;
  z->T=4; 
}
]],d,s,d,s)

  if h.eqAny(d,'ixh','ixl') or h.eqAny(s,'ixl','ixh') then
    ddInst[o]=util.format('ldr_%s%s',d,s)
  elseif h.eqAny(d,'iyh','iyl') or h.eqAny(s,'iyl','iyh') then
    fdInst[o]=util.format('ldr_%s%s',d,s)
  else
    inst[o]=util.format('ldr_%s%s',d,s)
  end
end

-- ld r,n (ld a,0x10)
local function loadrn(s,o)
  lines[#lines+1]=util.format([[
void ldr_%sn(z80* z)
{
  %s 
  z->r.q=0;
  z->T=4; 
}
]],s,readI('pc',s,0,3,true))

  if h.eqAny(s,'ixl','ixh') then
    ddInst[o]=util.format('ldr_%sn',s)
  elseif  h.eqAny(s,'iyl','iyh') then
    fdInst[o]=util.format('ldr_%sn',s)
  else
    inst[o]=util.format('ldr_%sn',s)
  end
end  

--ld r,(rr) (ld a,(hl))
local function loadri(d,s,o)
  if h.eqAny(s,'bc','de') then
    lines[#lines+1]=util.format([[
void ldri_%s%s(z80* z)
{
  z->r.mptr=z->r.%s;
  %s
  z->r.q=0;
  z->T=4; 
}
]],d,s,s,readI('mptr',d,0,3,true))
  else
    lines[#lines+1]=util.format([[
void ldri_%s%s(z80* z)
{
  %s
  z->r.q=0;
  z->T=4; 
}
]],d,s,read(s,d,0,3,true))
  end
  inst[o]=util.format('ldri_%s%s',d,s)
end  

--ld r,(ir+d) (ld a,(ix+1))
local function loadrid(d,s,o)
  lines[#lines+1]=util.format([[
void ldrid_%s%s(z80* z)
{
  %s
  %s
  %s
  %s
  %s
  %s
  %s
  z->r.q=0;
  z->T=4;
}
]],d,s,readI('pc','tm1',0,3,true),con('pc',1,1),con('pc',2,1),con('pc',3,1),con('pc',4,1),con('pc',5,1),readD(s,d,6,3,true))

  local i
  if s=='ix' then i=ddInst else i=fdInst end
  i[o]=util.format('ldrid_%s%s',d,s)
end

--ld (rr),r (ld (hl),b)
local function storei(d,s,o)
  lines[#lines+1]=util.format([[
void stoi_%s%s(z80* z)
{
  %s
  z->r.q=0;
  z->T=4;
}
]],d,s,write(d,s,0,3,true))

  inst[o]=util.format('stoi_%s%s',d,s)
end

--for mptr implementation
local function storei2(d,s,o)
  lines[#lines+1]=util.format([[
void stoi_%s%sExec(z80* z)
{
  z->r.mptrh=z->r.a;
}

void stoi_%s%s(z80* z)
{
  z->r.mptr=z->r.%s;
  %s
  %s
  z->r.q=0;
  z->T=4;
}
]],d,s,d,s,d,writeI('mptr',s,0,2,true),exec('stoi_'..d..s..'Exec',1,1))

  inst[o]=util.format('stoi_%s%s',d,s)
end

--ld (ir+d),r (ld (iy+1),c)
local function storeid(d,s,o)
  lines[#lines+1]=util.format([[
void stoid_%s%s(z80* z)
{
  %s
  %s
  %s
  %s
  %s
  %s
  %s
  z->r.q=0;
  z->T=4; 
}
]],d,s,readI('pc','tm1',0,3,true),con('pc',1,1),con('pc',2,1),con('pc',3,1),con('pc',4,1),con('pc',5,1),writeD(d,s,6,3,true))

  local i
  if d=='ix' then i=ddInst else i=fdInst end
  i[o]=util.format('stoid_%s%s',d,s)
end

r8={[0]='b','c','d','e','h','l',[7]='a'}
r8ix={b='b',c='c',d='d',e='e',h='ixh',l='ixl',a='a'}
r8iy={b='b',c='c',d='d',e='e',h='iyh',l='iyl',a='a'}

for i,s in pairs(r8) do
  for j,d in pairs(r8) do
    loadr(d,s,64+j*8+i)
    if h.eqAny(s,'h','l') or h.eqAny(d,'h','l') then
      loadr(r8ix[d],r8ix[s],64+j*8+i)
      loadr(r8iy[d],r8iy[s],64+j*8+i)
    end
  end

  loadrn(s,i*8+6)
  loadri(s,'hl',64+i*8+6)
  loadrid(s,'ix',64+i*8+6)
  loadrid(s,'iy',64+i*8+6)
  storei('hl',s,64+6*8+i)
  storeid('ix',s,64+6*8+i)
  storeid('iy',s,64+6*8+i)

  if h.eqAny(s,'h','l') then
    loadrn(r8ix[s],i*8+6)
    loadrn(r8iy[s],i*8+6)
  end
end

--ld (rr),n (ld (hl),0x10)
lines[#lines+1]=util.format([[
void storn(z80* z)
{
  %s
  %s
  z->r.q=0;
  z->T=4;
}
]],readI('pc','tm1',0,3,true),write('hl','tm1',1,3,true))
inst[0x36]='storn'

--ld (ir+d),n (ld (ix+0),0x0)
local function stornd(d)
  lines[#lines+1]=util.format([[
void storn%s(z80* z)
{
  %s
  %s
  %s
  %s
  %s
  z->r.q=0;
  z->T=4;
}
]],d,readI('pc','tm1',0,3,true),readI('pc','tm2',1,3,true),con('pc',2,1),con('pc',3,1),writeD(d,'tm2',4,3,true))

  local i
  if d=='ix' then i=ddInst else i=fdInst end
  i[0x36]=util.format('storn%s',d)
end

stornd('ix')
stornd('iy')

loadri('a','bc',0xa)
loadri('a','de',0x1a)

storei2('bc','a',0x2)
storei2('de','a',0x12)

--ld a,(nn)
lines[#lines+1]=util.format([[
void ldamem(z80* z)
{
  %s
  %s
  %s
  z->r.q=0;
  z->T=4; 
}
]],readI('pc','mptrl',0,3,true),readI('pc','mptrh',1,3,true),readI('mptr','a',2,3,true))
inst[0x3a]='ldamem'

--ld (nn),a
lines[#lines+1]=util.format([[
void stamemExec(z80* z)
{
  z->r.mptrh=z->r.a;
}

void stamem(z80* z)
{
  %s
  %s
  %s
  %s
  z->r.q=0;
  z->T=4;
}
]],readI('pc','mptrl',0,3,true),readI('pc','mptrh',1,3,true),writeI('mptr','a',2,2,true),exec('stamemExec',3,1))
inst[0x32]='stamem'


--ld a,i / ld a,r
--z->r.f=(z->r.f & 0x29) | (sz53cFlags[z->r.a] & 0xc0) | ((z->r.iff2 & 0x1) <<2);
local function ldari(s,o)
  lines[#lines+1]=util.format([[
void ldra%s(z80* z)
{
  z->r.a=z->r.%s;

  z->r.f=(z->r.f & 0x1) | (sz53cFlags[z->r.a] & 0xe8) | ((z->r.iff2 & 0x1) <<2);
  z->r.q=1;
  %s
  z->T=4; 
}
]],s,s,con('ir',0,1))
  edInst[o]=util.format('ldra%s',s)
end

ldari('i',0x57)
ldari('r',0x5f)

--ld i/r,a
local function ldria(s,o)
  lines[#lines+1]=util.format([[
void ldr%sa(z80* z)
{
  z->r.tm=z->r.ir;
  z->r.%s=z->r.a;
  z->r.q=0;
  %s
  z->T=4; 
}
]],s,s,con('tm',0,1))
  edInst[o]=util.format('ldr%sa',s)
end

ldria('i',0x47)
ldria('r',0x4f)

----------------------
--16-bits load group--
----------------------

--ld rr,nn (ld hl,0x4000)
local function load16r(d,o,g)
  lines[#lines+1]=util.format([[
void ld16r%s(z80* z)
{
  %s
  %s
  z->r.q=0;
  z->T=4;  
}
]],d,readI('pc',low[d],0,3,true),readI('pc',high[d],1,3,true))
  g[o]=util.format('ld16r%s',d)
end

load16r('bc',0x01,inst) --ld bc,nn
load16r('de',0x11,inst) --ld de,nn
load16r('hl',0x21,inst) --ld hl,nn
load16r('sp',0x31,inst) --ld sp,nn
load16r('ix',0x21,ddInst) --ld ix,nn
load16r('iy',0x21,fdInst) --ld iy,nn

--ld rr,(nn) ld hl,(0x8000)
local function load16ri(d,o,g,p)
  if not p then p='' end

  lines[#lines+1]=util.format([[
void ld16ri%s(z80* z)
{
  %s
  %s
  %s
  %s
  z->r.q=0;
  z->T=4;  
}
]],d..p,
  readI('pc','mptrl',0,3,true),
  readI('pc','mptrh',1,3,true),
  readI('mptr',low[d],2,3,true),
  read('mptr',high[d],3,3,true))
  g[o]=util.format('ld16ri%s',d..p)
end

load16ri('hl',0x2a,inst) --ld hl,(nn)
load16ri('bc',0x4b,edInst) --ld bc,(nn)
load16ri('de',0x5b,edInst) --ld de,(nn)
load16ri('hl',0x6b,edInst,'2') --ld hl,(nn)
load16ri('sp',0x7b,edInst) --ld sp,(nn)
load16ri('ix',0x2a,ddInst) --ld ix,(nn)
load16ri('iy',0x2a,fdInst) --ld iy,(nn)

local function store16ri(d,o,g,p)
  if not p then p='' end

  lines[#lines+1]=util.format([[
void st16ri%s(z80* z)
{
  %s
  %s
  %s
  %s
  z->r.q=0;
  z->T=4;  
}
]],d..p,
  readI('pc','mptrl',0,3,true),
  readI('pc','mptrh',1,3,true),
  writeI('mptr',low[d],2,3,true),
  write('mptr',high[d],3,3,true))
  g[o]=util.format('st16ri%s',d..p)
end

store16ri('hl',0x22,inst) --ld (nn),hl
store16ri('bc',0x43,edInst) --ld (nn),bc
store16ri('de',0x53,edInst) --ld (nn),de
store16ri('hl',0x63,edInst,'2') --ld (nn),hl
store16ri('sp',0x73,edInst) --ld (nn),sp
store16ri('ix',0x22,ddInst) --ld (nn),ix
store16ri('iy',0x22,fdInst) --ld (nn),iy

--ld rr,rr (ld sp,hl)
local function load16r(d,s,o,g)
  lines[#lines+1]=util.format([[
void ld16r%s%s(z80* z)
{
  z->r.%s=z->r.%s;
  z->r.q=0;
  %s
  %s
  z->T=4;  
}
]],d,s,d,s,con('ir',0,1),con('ir',1,1))
  g[o]=util.format('ld16r%s%s',d,s)
end

load16r('sp','hl',0xf9,inst)
load16r('sp','ix',0xf9,ddInst)
load16r('sp','iy',0xf9,fdInst)

--push rr (push hl)
local function pushr(d,o,g)
  lines[#lines+1]=util.format([[
void pushr%s(z80* z)
{
  %s
  %s
  %s
  z->r.q=0;
  z->T=4;  
}
]],d,con('ir',0,1),writeDc('sp',high[d],1,3,true),writeDc('sp',low[d],2,3,true))
  g[o]=util.format('pushr%s',d)
end

pushr('bc',0xc5,inst)
pushr('de',0xd5,inst)
pushr('hl',0xe5,inst)
pushr('af',0xf5,inst)
pushr('ix',0xe5,ddInst)
pushr('iy',0xe5,fdInst)

--pop rr (pop bc)
local function popr(d,o,g)
  lines[#lines+1]=util.format([[
void popr%s(z80* z)
{
  %s
  %s
  z->r.q=0;
  z->T=4;  
}
]],d,readI('sp',low[d],0,3,true),readI('sp',high[d],1,3,true))
  g[o]=util.format('popr%s',d)
end

popr('bc',0xc1,inst)
popr('de',0xd1,inst)
popr('hl',0xe1,inst)
popr('af',0xf1,inst)
popr('ix',0xe1,ddInst)
popr('iy',0xe1,fdInst)

----------------------------------------------
--Exchange, Block Transfer, and Search Group--
----------------------------------------------

-- ex de,hl
lines[#lines+1]=util.format([[
void exdehl(z80* z)
{
  uint16_t l=z->r.de;
  z->r.de=z->r.hl;
  z->r.hl=l;

  z->r.q=0;
  z->T=4; 
}
]])
inst[0xeb]='exdehl'

-- ex af,af'
lines[#lines+1]=util.format([[
void exafaf(z80* z)
{
  uint16_t l=z->r.af;
  z->r.af=z->r.afp;
  z->r.afp=l;

  z->r.q=0;
  z->T=4; 
}
]])
inst[0x08]='exafaf'


-- ex de,hl
lines[#lines+1]=util.format([[
void exx(z80* z)
{
  uint16_t lbc=z->r.bc;
  uint16_t lde=z->r.de;
  uint16_t lhl=z->r.hl;
  z->r.bc=z->r.bcp;
  z->r.de=z->r.dep;
  z->r.hl=z->r.hlp;
  z->r.bcp=lbc;
  z->r.dep=lde;
  z->r.hlp=lhl;

  z->r.q=0;
  z->T=4; 
}
]])
inst[0xd9]='exx'

local function exspi(d,o,g,t,m)
  lines[#lines+1]=util.format([[
void exsp%sExec(z80* z)
{
  z->r.%s=z->r.mptr;
}

void exsp%s(z80* z)
{
  %s
  %s
  %s
  %s
  %s
  %s
  %s
  z->r.q=0;
  z->T=4;
}
]],d,d,d,
  readI('sp','mptrl',0,3,true),
  read('sp','mptrh',1,3,true),
  con('sp',2,1),
  write('sp',high[d],3,3,true),
  writeDc('sp',low[d],4,3,true),
  con('sp',5,1),
  exec('exsp'..d..'Exec',6,1,true,'sp'))

  g[o]=util.format('exsp%s',d)
end

exspi('hl',0xe3,inst)
exspi('ix',0xe3,ddInst)
exspi('iy',0xe3,fdInst)

--ldi/ldd
local function ld(o,i,s)
  lines[#lines+1]=util.format([[
void ld%sExec(z80* z)
{
  z->r.hl+=%d;
  z->r.de+=%d;
  z->r.bc--;

  uint8_t n=z->r.a+z->r.tm1;
  z->r.f=(z->r.f & 0xc1) | (n & 0x8) | ((n & 0x2)<<4);
  z->r.f=(z->r.bc!=0) ? z->r.f | 0x4 : z->r.f;
  z->r.q=1;
}

void ld%s(z80* z)
{
  %s
  %s
  %s
  %s
  z->T=4;
}
]],s,i,i,s,
  read('hl','tm1',0,3,true),
  write('de','tm1',1,3,true),
  con('de',2,1),
  exec('ld'..s..'Exec',3,1,true,'de'))

  edInst[o]=util.format('ld%s',s)
end

ld(0xa0,1,'i')
ld(0xa8,-1,'d')

--ldir/lddr
local function ldr(o,i,s)
    lines[#lines+1]=util.format([[
void ld%srExec(z80* z)
{
  z->r.hl+=%d;
  z->r.de+=%d;
  
  uint8_t n=z->r.a+z->r.tm1;
  z->r.f=(z->r.f & 0xc1) | (n & 0x8) | ((n & 0x2)<<4);
  if(z->r.bc)
  {
    z->r.pc-=2;
    z->r.f=z->r.f | 0x4;
    z->r.mptr=z->r.pc+1;
  }
  z->r.q=1;
}

void ld%sr(z80* z)
{
  z->r.bc--;
  z->r.aux=z->r.de;
  %s
  %s
  %s
  %s
  if(z->r.bc)
  {
    %s
    %s
    %s
    %s
    %s
  }
  z->T=4;
}
]],s,i,i,s,
  read('hl','tm1',0,3,true),
  write('aux','tm1',1,3,true),
  con('aux',2,1),
  exec('ld'..s..'rExec',3,1,true,'aux'),
  con('aux',4,1),
  con('aux',5,1),
  con('aux',6,1),
  con('aux',7,1),
  con('aux',8,1))

  edInst[o]=util.format('ld%sr',s)
end

ldr(0xb0,1,'i')
ldr(0xb8,-1,'d')


--cpi/cpd
local function cpr(o,i,s)
  lines[#lines+1]=util.format([[
void cp%sExec(z80* z)
{
  uint8_t v=z->r.tm1;
  uint8_t r=z->r.a-v;

  _LOOKUP

  z->r.hl+=%d;
  z->r.mptr+=%d;
  z->r.bc--;

  if(hSubFlags[l&0x7])
  {
    uint8_t n=r-1;
    z->r.f=(sz53cFlags[r] & 0xc0) | (n & 0x8) | ((n & 0x2) << 4) | ((z->r.bc!=0) ? 0x4 : 0) | 0x12 | (z->r.f & 0x1);
  }
  else
    z->r.f=(sz53cFlags[r] & 0xc0) | (r & 0x8) | ((r & 0x2) << 4) | ((z->r.bc!=0) ? 0x4 : 0) | 0x2 | (z->r.f & 0x1);

  z->r.q=1;
}

void cp%s(z80* z)
{
  %s
  %s
  %s
  %s
  %s
  %s
  z->T=4;
}
]],s,i,i,s,
  read('hl','tm1',0,3,true),
  con('hl',1,1),
  con('hl',2,1),
  con('hl',3,1),
  con('hl',4,1),
  exec('cp'..s..'Exec',5,1,true,'hl'))

  edInst[o]=util.format('cp%s',s)
end

cpr(0xa1,1,'i')
cpr(0xa9,-1,'d')

--cpir/cpdr
local function cprr(o,i,s)
  lines[#lines+1]=util.format([[
void cp%srExec(z80* z)
{
  uint8_t v=z->r.tm1;
  uint8_t r=z->r.a-v;
  _LOOKUP

  z->r.hl+=%d;
  z->r.bc--;

  if(hSubFlags[l&0x7])
  {
    uint8_t n=r-1;
    z->r.f=(sz53cFlags[r] & 0xc0) | (n & 0x8) | ((n & 0x2) << 4) | ((z->r.bc!=0) ? 0x4 : 0) | 0x12 | (z->r.f & 0x1);
  }
  else
    z->r.f=(sz53cFlags[r] & 0xc0) | (r & 0x8) | ((r & 0x2) << 4) | ((z->r.bc!=0) ? 0x4 : 0) | 0x2 | (z->r.f & 0x1);

  if(r==0 || z->r.bc==0)
  {
    z->r.mptr+=%d;
  }
  else
  {
    %s
    %s
    %s
    %s
    %s
    z->r.pc-=2;
    z->r.mptr=z->r.pc+1;
  }

  z->r.q=1;
}

void cp%sr(z80* z)
{
  z->r.aux=z->r.hl;
  %s
  %s
  %s
  %s
  %s
  %s
  z->T=4;
}
]],s,i,i,
  con('aux',6,1),
  con('aux',7,1),
  con('aux',8,1),
  con('aux',9,1),
  con('aux',10,1),
  s,
  read('aux','tm1',0,3,true),
  con('aux',1,1),
  con('aux',2,1),
  con('aux',3,1),
  con('aux',4,1),
  exec('cp'..s..'rExec',5,1,true,'aux'))

  edInst[o]=util.format('cp%sr',s)
end

cprr(0xb1,1,'i')
cprr(0xb9,-1,'d')

--------------------------
--8-Bit Arithmetic Group--
--------------------------

local function arithmetic8(s,o,g,name,oper,discard)
  if(h.eqAny(s,'hl','ix','iy','nn')) then
      lines[#lines+1]=util.format([[
void %s8_%sExec(z80* z)
{
  uint8_t v=z->r.tm2;
  %s
]],name,s,oper)
if not discard then lines[#lines+1]='z->r.a=(uint8_t)r;' end
lines[#lines+1]=util.format([[
  }
]])
  end

  lines[#lines+1]=util.format([[
void %s8_%s(z80* z)
{]],name,s)
  if s=='hl' then
    lines[#lines+1]=util.format([[
  %s
  %s
]],read('hl','tm2',0,2,true),exec(name..'8_'..s..'Exec',1,1))
  elseif s=='ix' or s=='iy' then
    lines[#lines+1]=util.format([[
  %s
  %s
  %s
  %s
  %s
  %s
  %s
  %s
]],readI('pc','tm1',0,3,true),con('pc',1,1),con('pc',2,1),con('pc',3,1),con('pc',4,1),con('pc',5,1),readD(s,'tm2',6,2,true),exec(name..'8_'..s..'Exec',7,1))
  elseif s=='nn' then
    lines[#lines+1]=util.format([[
  %s
  %s
]],readI('pc','tm2',0,2,true),exec(name..'8_'..s..'Exec',1,1))
  else
  lines[#lines+1]=util.format([[
  uint8_t v=z->r.%s;
  %s
]],s,oper)
  if not discard then lines[#lines+1]='z->r.a=(uint8_t)r;' end
  end
lines[#lines+1]=util.format([[
  z->T=4; 
  z->r.q=1;
}
]])
  g[o]=util.format('%s8_%s',name,s)
end

--add
local function add8(s,o,g)
  arithmetic8(s,o,g,'add',[[
  uint16_t r=z->r.a+v;
  _LOOKUP
  
  z->r.f=sz53cFlags[r&0x1ff] | hAddFlags[l&0x7] | vAddFlags[l>>4];
  ]])
end


--add
local function adc8(s,o,g)
  arithmetic8(s,o,g,'adc',[[
  uint16_t r=z->r.a+v+(z->r.f & 0x1);
  _LOOKUP
  
  z->r.f=sz53cFlags[r&0x1ff] | hAddFlags[l&0x7] | vAddFlags[l>>4];
  ]])
end

local function sub8(s,o,g)
  arithmetic8(s,o,g,'sub',[[
  uint16_t r=z->r.a-v;
  _LOOKUP

  z->r.f=sz53cFlags[r&0x1ff] | hSubFlags[l&0x7] | vSubFlags[l>>4] | 0x2;
  ]])
end

local function sbc8(s,o,g)
  arithmetic8(s,o,g,'sbc',[[
  uint16_t r=z->r.a-v-(z->r.f & 0x1);
  _LOOKUP

  z->r.f=sz53cFlags[r&0x1ff] | hSubFlags[l&0x7] | vSubFlags[l>>4] | 0x2;
  ]])
end

local function and8(s,o,g)
  arithmetic8(s,o,g,'and',[[
  uint8_t r=z->r.a & v;
  
  z->r.f=(sz53pcFlags[r] & 0xEC) | 0x10;
  ]])
end

local function or8(s,o,g)
  arithmetic8(s,o,g,'or',[[
  uint8_t r=z->r.a | v;
  
  z->r.f=(sz53pcFlags[r] & 0xEC);
  ]])
end

local function xor8(s,o,g)
  arithmetic8(s,o,g,'xor',[[
  uint8_t r=z->r.a ^ v;
  
  z->r.f=(sz53pcFlags[r] & 0xEC);
  ]])
end

local function cp8(s,o,g)
  arithmetic8(s,o,g,'cp',[[
  uint16_t r=z->r.a-v;
  _LOOKUP

  z->r.f=(sz53cFlags[r&0x1ff]  & 0xd7) | (v & 0x28) | hSubFlags[l&0x7] | vSubFlags[l>>4] | 0x2;
  ]],true)
end

local function incdec8(s,o,g,name,d,flags)
  if(h.eqAny(s,'hl','ix','iy')) then
      lines[#lines+1]=util.format([[
void %s8_%sExec(z80* z)
{
  uint8_t v=z->r.tm2+%d;
  z->r.tm2=v;
  %s
]],name,s,d,flags)

lines[#lines+1]=util.format([[
  }
]])
  end

  lines[#lines+1]=util.format([[
void %s8_%s(z80* z)
{]],name,s)
  if s=='hl' then
    lines[#lines+1]=util.format([[
  %s
  %s
  %s
]],read('hl','tm2',0,3,true),exec(name..'8_'..s..'Exec',1,1,true,'hl'),write('hl','tm2',2,3,true))
  elseif s=='ix' or s=='iy' then
    lines[#lines+1]=util.format([[
  %s
  %s
  %s
  %s
  %s
  %s
  %s
  %s
  %s
]],readI('pc','tm1',0,3,true),con('pc',1,1),con('pc',2,1),con('pc',3,1),con('pc',4,1),con('pc',5,1),readD(s,'tm2',6,3,true),execD(name..'8_'..s..'Exec',7,1,true,s),writeD(s,'tm2',8,3,true))
  else
  lines[#lines+1]=util.format([[
  uint8_t v=z->r.%s+%d;
  z->r.%s=v;
  %s
]],s,d,s,flags)
  end
lines[#lines+1]=util.format([[
  z->T=4;
  z->r.q=1;
}
]],t,m)
  g[o]=util.format('%s8_%s',name,s)
end

--inc
local function inc8(s,o,g)
  incdec8(s,o,g,'inc',1,[[
  _LOOKUP2
  
  z->r.f=(sz53cFlags[v] & 0xfe) | hAddFlags[l&0x7] | vAddFlags[l>>4] | (z->r.f & 0x1);
  ]])
end

--inc
local function dec8(s,o,g)
  incdec8(s,o,g,'dec',-1,[[
  _LOOKUP3
  
  z->r.f=(sz53cFlags[v] & 0xfe) | hSubFlags[l&0x7] | vSubFlags[l>>4] | 0x2 | (z->r.f & 0x1);
  ]])
end


lines[#lines+1]=util.format([[
void daa(z80* z)
{
  uint8_t v=0;
  uint8_t c=z->r.f & 0x1;
  if((z->r.f & 0x10) || ((z->r.a&0xf)>0x9)) v=0x6;
  if((z->r.f & 0x1) || z->r.a>0x99) v|=0x60;
  if(z->r.a>0x99) c=0x1;

  if(z->r.f & 0x2)
  {
    uint16_t r=z->r.a-v;
    _LOOKUP

    z->r.f=sz53pcFlags[r&0xff] | hSubFlags[l&0x7] | 0x2 |c;
    z->r.a=(uint8_t)r;
  }
  else
  {
    uint16_t r=z->r.a+v;
    _LOOKUP

    z->r.f=sz53pcFlags[r&0xff] | hAddFlags[l&0x7] | c;
    z->r.a=(uint8_t)r;
  }

  z->r.q=1;
  z->T=4;
}
]])
inst[0x27]='daa'


lines[#lines+1]=util.format([[
void cpl(z80* z)
{
  z->r.a^=0xff;

  z->r.f=(z->r.f & 0xd7) | (z->r.a & 0x28) | 0x12;

  z->r.q=1;
  z->T=4;
}
]])
inst[0x2f]='cpl'


lines[#lines+1]=util.format([[
void neg(z80* z)
{
  uint8_t v=z->r.a;
  z->r.a=0;
  uint16_t r=z->r.a-v;
  _LOOKUP

  z->r.q=1;
  z->r.f=sz53cFlags[r&0x1ff] | hSubFlags[l&0x7] | vSubFlags[l>>4] | 0x2;
  z->r.a=r;
  z->T=4;
}
]])
edInst[0x44]='neg'

--Undocumented
edInst[0x4c]='neg'
edInst[0x54]='neg'
edInst[0x5c]='neg'
edInst[0x64]='neg'
edInst[0x6c]='neg'
edInst[0x74]='neg'
edInst[0x7c]='neg'

lines[#lines+1]=util.format([[
void ccf(z80* z)
{
  uint8_t c=z->r.f & 0x1;
  uint8_t nc=c ? 0 : 0x1;
  uint8_t v=z->r.q ? (z->r.a & 0x28) : ((z->r.f | z->r.a) & 0x28);
  z->r.f=(z->r.f & 0xc4) | v | (c<<4) | nc;

  z->r.q=1;
  z->T=4;
}
]])
inst[0x3f]='ccf'


lines[#lines+1]=util.format([[
void scf(z80* z)
{
  uint8_t v=z->r.q ? (z->r.a & 0x28) : ((z->r.f | z->r.a) & 0x28);
  z->r.f=(z->r.f & 0xc4) | v | 0x1;

  z->r.q=1;
  z->T=4;
}
]])
inst[0x37]='scf'

lines[#lines+1]=util.format([[
void di(z80* z)
{
  z->r.iff=0; z->r.iff2=0;

  z->r.q=0;
  z->T=4;
}]])
inst[0xf3]='di'

-- *Todo: next instruction not int
lines[#lines+1]=util.format([[
void ei(z80* z)
{
  z->r.iff=1; z->r.iff2=1;
  z->r.q=0;
  z->dispatch=nInst;
  z->T=4;
}]])
inst[0xfb]='ei'


lines[#lines+1]=util.format([[
void im0(z80* z)
{
  z->r.iMode=0;
  z->r.q=0;
  z->T=4;
}]])
edInst[0x46]='im0'
edInst[0x66]='im0'
edInst[0x4e]='im0'
edInst[0x6e]='im0'

lines[#lines+1]=util.format([[
void im1(z80* z)
{
  z->r.iMode=1;
  z->r.q=0;
  z->T=4;
}]])
edInst[0x56]='im1'
edInst[0x76]='im1'

lines[#lines+1]=util.format([[
void im2(z80* z)
{
  z->r.iMode=2;
  z->r.q=0;
  z->T=4;
}]])
edInst[0x5e]='im2'
edInst[0x7e]='im2'

for i,o in pairs(r8) do
  add8(o,0x80+i,inst,4,1)
  adc8(o,0x88+i,inst,4,1)
  sub8(o,0x90+i,inst,4,1)
  sbc8(o,0x98+i,inst,4,1)
  and8(o,0xa0+i,inst,4,1)
  or8(o,0xb0+i,inst,4,1)
  xor8(o,0xa8+i,inst,4,1)
  cp8(o,0xb8+i,inst,4,1)
  inc8(o,0x4+ls(i,3),inst,4,1)
  dec8(o,0x5+ls(i,3),inst,4,1)

  if h.eqAny(o,'h','l') then
    add8(r8ix[o],0x80+i,ddInst)
    add8(r8iy[o],0x80+i,fdInst)

    adc8(r8ix[o],0x88+i,ddInst)
    adc8(r8iy[o],0x88+i,fdInst)

    sub8(r8ix[o],0x90+i,ddInst)
    sub8(r8iy[o],0x90+i,fdInst)

    sbc8(r8ix[o],0x98+i,ddInst)
    sbc8(r8iy[o],0x98+i,fdInst)

    and8(r8ix[o],0xa0+i,ddInst)
    and8(r8iy[o],0xa0+i,fdInst)

    or8(r8ix[o],0xb0+i,ddInst)
    or8(r8iy[o],0xb0+i,fdInst)

    xor8(r8ix[o],0xa8+i,ddInst)
    xor8(r8iy[o],0xa8+i,fdInst)

    cp8(r8ix[o],0xb8+i,ddInst)
    cp8(r8iy[o],0xb8+i,fdInst)

    inc8(r8ix[o],0x4+ls(i,3),ddInst)
    inc8(r8iy[o],0x4+ls(i,3),fdInst)

    dec8(r8ix[o],0x5+ls(i,3),ddInst)
    dec8(r8iy[o],0x5+ls(i,3),fdInst)
  end
end

add8('nn',0xc6,inst,7,2)
add8('hl',0x86,inst,7,2)
add8('ix',0x86,ddInst,19,5)
add8('iy',0x86,fdInst,19,5)

adc8('nn',0xce,inst,7,2)
adc8('hl',0x8e,inst,7,2)
adc8('ix',0x8e,ddInst,19,5)
adc8('iy',0x8e,fdInst,19,5)

sub8('nn',0xd6,inst,7,2)
sub8('hl',0x96,inst,7,2)
sub8('ix',0x96,ddInst,19,5)
sub8('iy',0x96,fdInst,19,5)

sbc8('nn',0xde,inst,7,2)
sbc8('hl',0x9e,inst,7,2)
sbc8('ix',0x9e,ddInst,19,5)
sbc8('iy',0x9e,fdInst,19,5)

and8('nn',0xe6,inst,7,2)
and8('hl',0xa6,inst,7,2)
and8('ix',0xa6,ddInst,19,5)
and8('iy',0xa6,fdInst,19,5)

or8('nn',0xf6,inst,7,2)
or8('hl',0xb6,inst,7,2)
or8('ix',0xb6,ddInst,19,5)
or8('iy',0xb6,fdInst,19,5)

xor8('nn',0xee,inst,7,2)
xor8('hl',0xae,inst,7,2)
xor8('ix',0xae,ddInst,19,5)
xor8('iy',0xae,fdInst,19,5)

cp8('nn',0xfe,inst,7,2)
cp8('hl',0xbe,inst,7,2)
cp8('ix',0xbe,ddInst,19,5)
cp8('iy',0xbe,fdInst,19,5)


inc8('hl',0x34,inst,7,2)
inc8('ix',0x34,ddInst,19,5)
inc8('iy',0x34,fdInst,19,5)

dec8('hl',0x35,inst,7,2)
dec8('ix',0x35,ddInst,19,5)
dec8('iy',0x35,fdInst,19,5)

---------------------------
--16-Bit Arithmetic Group--
---------------------------

-- *TODO: Machine cycles not correct.
local function arithmetic16(d,s,o,g,name,oper)
  lines[#lines+1]=util.format([[
void %s16_%s_%s(z80* z)
{
  uint16_t v=z->r.%s;
  uint16_t o=z->r.%s;
  %s

  %s
  %s
  %s
  %s
  %s
  %s
  %s

  z->r.%s=r;
  z->r.q=1;
  z->T=4; 
}]],name,d,s,s,d,oper,con('ir',0,1),con('ir',1,1),con('ir',2,1),con('ir',3,1),con('ir',4,1),con('ir',5,1),con('ir',6,1),d)

  g[o]=util.format('%s16_%s_%s',name,d,s)
end

local function add16(d,s,o,g)
  arithmetic16(d,s,o,g,'add',util.format([[
    uint32_t r=o+v;
    z->r.mptr=o+1;
    _LOOKUP16ADD
    
    z->r.f=(z->r.f & 0xc4) | (sz53cFlags[(r&0x1ff00)>>8] & 0x29) | hAddFlags[l&0x7];
  ]]))
end

local function adc16(d,s,o,g)
  arithmetic16(d,s,o,g,'adc',util.format([[
    uint32_t r=o+v+(z->r.f & 0x1);
    z->r.mptr=o+1;
    _LOOKUP16
    
    z->r.f=(sz53cFlags[(r&0x1ff00)>>8] & 0xA9) | hAddFlags[l&0x7] | vAddFlags[l>>4] | (((uint16_t)r) ? 0 : 0x40);
  ]],d,d))
end

local function sbc16(d,s,o,g)
  arithmetic16(d,s,o,g,'sbc',util.format([[
    uint32_t r=z->r.%s-v-(z->r.f & 0x1);
    z->r.mptr=o+1;
    _LOOKUP16
    
    z->r.f=(sz53cFlags[(r&0x1ff00)>>8] & 0xa9)  | hSubFlags[l&0x7] | vSubFlags[l>>4] | (((uint16_t)r) ? 0x2 : 0x42);
  ]],d,d))
end

local function incdec16(d,i,o,g,name)
  lines[#lines+1]=util.format([[
void %s16_%s(z80* z)
{
  z->r.%s+=%d;
  z->r.q=0;
  %s
  %s
  z->T=4;
}
]],name,d,d,i,con('ir',0,1),con('ir',1,1))
  g[o]=util.format("%s16_%s",name,d)
end

local r16={[0]='bc','de','hl','sp'}

for k,v in pairs(r16) do
  add16('hl',v,ls(k,4)+0x9,inst)
  adc16('hl',v,ls(k,4)+0x4a,edInst)
  sbc16('hl',v,ls(k,4)+0x42,edInst)
  add16('ix',v=='hl' and 'ix' or v,ls(k,4)+0x9,ddInst)
  add16('iy',v=='hl' and 'iy' or v,ls(k,4)+0x9,fdInst)
  incdec16(v,1,ls(k,4)+0x3,inst,'inc')
  incdec16(v,-1,ls(k,4)+0xb,inst,'dec')
end


incdec16('ix',1,0x23,ddInst,'inc')
incdec16('iy',1,0x23,fdInst,'inc')

incdec16('ix',-1,0x2b,ddInst,'dec')
incdec16('iy',-1,0x2b,fdInst,'dec')

--------------------------
--Rotate and Shift Group--
--------------------------

local function rlca()
  lines[#lines+1]=util.format([[
void rlca(z80* z)
{
  uint16_t v=z->r.a<<1;
  z->r.a=v | (v>>8);
  z->r.f=(z->r.f & 0xc4) | (z->r.a & 0x28) | (v>>8);

  z->r.q=1;
  z->T=4;
}]])
  inst[0x7]='rlca'
end


rlca()


local function rla()
  lines[#lines+1]=util.format([[
void rla(z80* z)
{
  uint16_t v=(z->r.a<<1) | (z->r.f & 0x1);
  z->r.a=v;
  z->r.f=(z->r.f & 0xc4) |  (z->r.a & 0x28) | (v>>8);
  
  z->r.q=1;
  z->T=4;
}]])
  inst[0x17]='rla'
end

rla()

local function rrca()
  lines[#lines+1]=util.format([[
void rrca(z80* z)
{
  uint8_t c=z->r.a & 0x1;
  z->r.a=((z->r.a & 0x1)<<7) | (z->r.a>>1);
  z->r.f=(z->r.f & 0xc4) | (z->r.a & 0x28) | c;

  z->r.q=1;
  z->T=4;
}]])
  inst[0x0f]='rrca'
end

rrca()

local function rra()
  lines[#lines+1]=util.format([[
void rra(z80* z)
{
  uint8_t c=(z->r.f & 0x1)<<7;
  uint8_t cc=z->r.a & 0x1;
  uint16_t v=(z->r.a>>1) | c;
  z->r.f=(z->r.f & 0xc4) | (v & 0x28) | cc;
  z->r.a=v;
   
  z->r.q=1; 
  z->T=4;
}]])
  inst[0x1f]='rra'
end

rra()


local function shiftO(s,o,g,op,name,p,copy)
  if p==nil then p=true end
  if copy==nil then copy='' end
  if(h.eqAny(s,'hl','ix','iy')) then
      lines[#lines+1]=util.format([[
void %s_%s%sExec(z80* z)
{
  %s
]],name,s,copy,op)
    if copy~='' then
      lines[#lines+1]=util.format([[
  z->r.%s=v;
]],copy)
    end
    lines[#lines+1]=util.format([[
  }
]])
  end

  lines[#lines+1]=util.format([[
void %s_%s%s(z80* z)
{]],name,s,copy)
  if s=='hl' then
    lines[#lines+1]=util.format([[
  %s
  %s
  z->T=4;
]],read('hl','tm2',0,3,true),exec(name..'_'..s..'Exec',1,1,true,'hl'))
  if p then
    lines[#lines+1]=util.format([[
  %s
]],write('hl','tm2',2,3,true))
  end
  elseif s=='ix' or s=='iy' then

    lines[#lines+1]=util.format([[
  %s
  %s
  %s
  %s
  z->T=3;
]],con('pc',0,1),con('pc',1,1),readD(s,'tm2',2,3,true),execD(name..'_'..s..copy..'Exec',3,1,true,s))
  if p then
    lines[#lines+1]=util.format([[
  %s
]],writeD(s,'tm2',4,3,true))
  end
  else
    lines[#lines+1]=util.format([[
  %s
  z->T=4;
  ]],op)
end

lines[#lines+1]=util.format([[
  //z->T=4;
}
]],t,m)
  g[o]=util.format('%s_%s%s',name,s,copy)
end

function rlc(s,o,g,copy)
  local op
  if(h.eqAny(s,'hl','ix','iy')) then
    op=[[
  uint16_t v=(z->r.tm2<<1) | (z->r.tm2>>7);
  z->r.tm2=v;
  z->r.f=sz53pcFlags[v&0x1ff];
  z->r.q=1;
    ]]
  else
    op=util.format([[
  uint16_t v=(z->r.%s<<1) | (z->r.%s>>7);
  z->r.%s=v;
  z->r.f=sz53pcFlags[v&0x1ff];
  z->r.q=1;
]],s,s,s)
  end

  return shiftO(s,o,g,op,'rlc',nil,copy)
end

function rl(s,o,g,copy)
  local op
  if(h.eqAny(s,'hl','ix','iy')) then
    op=[[
  uint16_t v=(z->r.tm2<<1) | (z->r.f & 0x1);
  z->r.tm2=v;
  z->r.f=sz53pcFlags[v&0x1ff];
  z->r.q=1;
    ]]
  else
    op=util.format([[
  uint16_t v=(z->r.%s<<1) | (z->r.f & 0x1);
  z->r.%s=v;
  z->r.f=sz53pcFlags[v&0x1ff];
  z->r.q=1;
]],s,s,s)
  end

  return shiftO(s,o,g,op,'rl',nil,copy)
end

function rrc(s,o,g,copy)
  local op
  if(h.eqAny(s,'hl','ix','iy')) then
    op=[[
  uint16_t v=(z->r.tm2>>1) | ((z->r.tm2&0x1)<<7);
  z->r.tm2=v;
  z->r.f=sz53pcFlags[v&0xff] | (v>>7);
  z->r.q=1;
    ]]
  else
    op=util.format([[
  uint16_t v=(z->r.%s>>1) | ((z->r.%s & 0x1)<<7);
  z->r.%s=v;
  z->r.f=sz53pcFlags[v&0xff] | (v>>7);
  z->r.q=1;
]],s,s,s)
  end

  return shiftO(s,o,g,op,'rrc',nil,copy)
end

function rr(s,o,g,copy)
  local op
  if(h.eqAny(s,'hl','ix','iy')) then
    op=[[
  uint8_t m=z->r.tm2;
  uint16_t v=(m>>1) | ((z->r.f&0x1)<<7);
  z->r.tm2=v;
  z->r.f=sz53pcFlags[v&0xff] | (m&0x1);
  z->r.q=1;
    ]]
  else
    op=util.format([[
  uint8_t m=z->r.%s;
  uint16_t v=(m>>1) | ((z->r.f&0x1)<<7);
  z->r.%s=v;
  z->r.f=sz53pcFlags[v&0xff] | (m&0x1);
  z->r.q=1;
]],s,s)
  end

  return shiftO(s,o,g,op,'rr',nil,copy)
end

function sla(s,o,g,copy)
  local op
  if(h.eqAny(s,'hl','ix','iy')) then
    op=[[
  uint16_t v=(z->r.tm2<<1);
  z->r.tm2=v;
  z->r.f=sz53pcFlags[v];
  z->r.q=1;
    ]]
  else
    op=util.format([[
  uint16_t v=(z->r.%s<<1);
  z->r.%s=v;
  z->r.f=sz53pcFlags[v];
  z->r.q=1;
]],s,s,s)
  end

  return shiftO(s,o,g,op,'sla',nil,copy)
end

function sll(s,o,g,copy)
  local op
  if(h.eqAny(s,'hl','ix','iy')) then
    op=[[
  uint16_t v=(z->r.tm2<<1) | 0x1;
  z->r.tm2=v;
  z->r.f=sz53pcFlags[v];
  z->r.q=1;
    ]]
  else
    op=util.format([[
  uint16_t v=(z->r.%s<<1) | 0x1;
  z->r.%s=v;
  z->r.f=sz53pcFlags[v];
  z->r.q=1;
]],s,s,s)
  end

  return shiftO(s,o,g,op,'sll',nil,copy)
end

function sra(s,o,g,copy)
  local op
  if(h.eqAny(s,'hl','ix','iy')) then
    op=[[
  uint8_t m=z->r.tm2;
  uint16_t v=(m>>1) | (m&0x80);
  z->r.tm2=v;
  z->r.f=sz53pcFlags[v&0xff] | (m&0x1);
  z->r.q=1;
    ]]
  else
    op=util.format([[
  uint8_t m=z->r.%s;
  uint16_t v=(m>>1) | (m&0x80);
  z->r.%s=v;
  z->r.f=sz53pcFlags[v&0xff] | (m&0x1);
  z->r.q=1;
]],s,s)
  end

  return shiftO(s,o,g,op,'sra',nil,copy)
end

function srl(s,o,g,copy)
  local op
  if(h.eqAny(s,'hl','ix','iy')) then
    op=[[
  uint8_t m=z->r.tm2;
  uint16_t v=(m>>1);
  z->r.tm2=v;
  z->r.f=sz53pcFlags[v&0xff] | (m&0x1);
  z->r.q=1;
    ]]
  else
    op=util.format([[
  uint8_t m=z->r.%s;
  uint16_t v=(m>>1);
  z->r.%s=v;
  z->r.f=sz53pcFlags[v&0xff] | (m&0x1);
  z->r.q=1;
]],s,s)
  end

  return shiftO(s,o,g,op,'srl',nil,copy)
end

local function rld()
  lines[#lines+1]=util.format([[
void rldExec(z80* z)
{
  uint8_t m=z->r.tm2;
  z->r.tm2=((z->r.a & 0xf) | (m<<4));
  z->r.a=(z->r.a & 0xf0) | (m>>4);
  z->r.f=sz53pcFlags[z->r.a] | (z->r.f & 0x1);
  z->r.mptr=z->r.hl+1;
}

void rld(z80* z)
{
  %s
  %s
  %s
  %s
  %s
  %s

  z->r.q=1;
  z->T=4;
}
]],read('hl','tm2',0,3,true),exec('rldExec',1,1,true,'hl'),con('hl',2,1),con('hl',3,1),con('hl',4,1),write('hl','tm2',5,3,true))
  edInst[0x6f]='rld'
end

rld()

local function rrd()
  lines[#lines+1]=util.format([[
void rrdExec(z80* z)
{
  uint8_t m=z->r.tm2;
  z->r.tm2=((z->r.a<<4) | (m>>4));
  z->r.a=(z->r.a & 0xf0) | (m&0xf);

  z->r.f=sz53pcFlags[z->r.a] | (z->r.f & 0x1);
  z->r.mptr=z->r.hl+1;
}

void rrd(z80* z)
{
  %s
  %s
  %s
  %s
  %s
  %s

  z->r.q=1;
  z->T=4;
}
]],read('hl','tm2',0,3,true),exec('rrdExec',1,1,true,'hl'),con('hl',2,1),con('hl',3,1),con('hl',4,1),write('hl','tm2',5,3,true))
  edInst[0x67]='rrd'
end

rrd()

function bit(s,b,o,g,p)
  local op
  if(h.eqAny(s,'ix','iy')) then
    op=util.format([[
  uint8_t d=(z->r.%s+((int8_t)z->r.tm1))>>8;
  uint8_t v=z->r.tm2 & (0x1<<%d);
  z->r.f=(sz53cFlags[v] & 0x80) | (sz53cFlags[d] & 0x28) | ((v) ? 0x10 : 0x54) | (z->r.f & 0x1);
  z->r.q=1;
]],s,b,b)
  elseif s=='hl' then
    op=util.format([[
  uint8_t v=z->r.tm2 & (0x1<<%d);
  z->r.f=(sz53cFlags[v] & 0x80) | (sz53cFlags[z->r.mptrh] & 0x28) | ((v) ? 0x10 : 0x54) | (z->r.f & 0x1);
  z->r.q=1;
]],b)
  else
    op=util.format([[
  uint8_t v=z->r.%s & (0x1<<%d);
  z->r.f=(sz53cFlags[v] & 0x80) | (sz53cFlags[z->r.%s] & 0x28) | ((v) ? 0x10 : 0x54) | (z->r.f & 0x1);
  z->r.q=1;
]],s,b,s)
  end

  return shiftO(s,o,g,op,'bit_'..b,p,copy)
end

function set(s,b,o,g,p,copy)
  local op
  if(h.eqAny(s,'hl','ix','iy')) then
    op=util.format([[
  uint8_t v=z->r.tm2 | (0x1<<%d);
  z->r.tm2=v;
  z->r.q=0;
    ]],b)
  else
    op=util.format([[
  uint8_t v=z->r.%s | (0x1<<%d);
  z->r.%s=v;
  z->r.q=0;
]],s,b,s)
  end

  return shiftO(s,o,g,op,'set_'..b,p,copy)
end

function res(s,b,o,g,p,copy)
  local op
  if(h.eqAny(s,'hl','ix','iy')) then
    op=util.format([[
  uint8_t v=z->r.tm2 & (0xff ^ (0x1<<%d)); 
  z->r.tm2=v; 
  z->r.q=0;
    ]],b)
  else
    op=util.format([[
  uint8_t v=z->r.%s & (0xff ^ (0x1<<%d)); 
  z->r.%s=v;
  z->r.q=0;
]],s,b,s)
  end

  return shiftO(s,o,g,op,'res_'..b,nil,copy)
end

for i=0,7 do
  bit('hl',i,ls(i,3)+0x46,cbInst,false)
  bit('ix',i,ls(i,3)+0x46,ddcbInst,false)
  bit('iy',i,ls(i,3)+0x46,fdcbInst,false)

  res('hl',i,ls(i,3)+0x86,cbInst)
  res('ix',i,ls(i,3)+0x86,ddcbInst)
  res('iy',i,ls(i,3)+0x86,fdcbInst)

  set('hl',i,ls(i,3)+0xC6,cbInst)
  set('ix',i,ls(i,3)+0xC6,ddcbInst)
  set('iy',i,ls(i,3)+0xC6,fdcbInst)
end

for k,v in pairs(r8) do
  rlc(v,k,cbInst)
  rl(v,k+0x10,cbInst)
  rrc(v,k+0x8,cbInst)
  rr(v,k+0x18,cbInst)
  sla(v,k+0x20,cbInst)
  sll(v,k+0x30,cbInst) --Undocumented
  sra(v,k+0x28,cbInst)
  srl(v,k+0x38,cbInst)

  rlc('ix',k,ddcbInst,v)
  rlc('iy',k,fdcbInst,v)

  rl('ix',k+0x10,ddcbInst,v)
  rl('iy',k+0x10,fdcbInst,v)

  rrc('ix',k+0x8,ddcbInst,v)
  rrc('iy',k+0x8,fdcbInst,v)

  rr('ix',k+0x18,ddcbInst,v)
  rr('iy',k+0x18,fdcbInst,v)

  sla('ix',k+0x20,ddcbInst,v)
  sla('iy',k+0x20,fdcbInst,v)

  sll('ix',k+0x30,ddcbInst,v)
  sll('iy',k+0x30,fdcbInst,v)

  sra('ix',k+0x28,ddcbInst,v)
  sra('iy',k+0x28,fdcbInst,v)

  srl('ix',k+0x38,ddcbInst,v)
  srl('iy',k+0x38,fdcbInst,v)

  for i=0,7 do
    bit(v,i,ls(i,3)+k+0x40,cbInst,false)
    res(v,i,ls(i,3)+k+0x80,cbInst)
    set(v,i,ls(i,3)+k+0xC0,cbInst)

    res('ix',i,ls(i,3)+k+0x80,ddcbInst,true,v)
    res('iy',i,ls(i,3)+k+0x80,fdcbInst,true,v)

    set('ix',i,ls(i,3)+k+0xC0,ddcbInst,true,v)
    set('iy',i,ls(i,3)+k+0xC0,fdcbInst,true,v)

    ddcbInst[ls(i,3)+k+0x40]='bit_'..i..'_ix'
    fdcbInst[ls(i,3)+k+0x40]='bit_'..i..'_iy'
  end
end

rlc('hl',0x6,cbInst)
rlc('ix',0x6,ddcbInst)
rlc('iy',0x6,fdcbInst)

rl('hl',0x16,cbInst)
rl('ix',0x16,ddcbInst)
rl('iy',0x16,fdcbInst)

rrc('hl',0x0e,cbInst)
rrc('ix',0x0e,ddcbInst)
rrc('iy',0x0e,fdcbInst)

rr('hl',0x1e,cbInst)
rr('ix',0x1e,ddcbInst)
rr('iy',0x1e,fdcbInst)

sla('hl',0x26,cbInst)
sla('ix',0x26,ddcbInst)
sla('iy',0x26,fdcbInst)

sll('hl',0x36,cbInst)
sll('ix',0x36,ddcbInst)
sll('iy',0x36,fdcbInst)

sra('hl',0x2e,cbInst)
sra('ix',0x2e,ddcbInst)
sra('iy',0x2e,fdcbInst)

srl('hl',0x3e,cbInst)
srl('ix',0x3e,ddcbInst)
srl('iy',0x3e,fdcbInst)

lines[#lines+1]=util.format([[
void rettExec(z80* z)
{
  z->r.mptr=z->r.pc;
}
]])

lines[#lines+1]=util.format([[
void callccExec(z80* z)
{
  z->r.pc=z->r.mptr;
}
]])

local function jmp()
  lines[#lines+1]=util.format([[
void jmp(z80* z)
{
  %s
  %s
  %s
  z->r.q=0;
  z->T=4;
}]],readI('pc','mptrl',0,3,true),read('pc','mptrh',1,2,true),exec('callccExec',2,1))
  inst[0xc3]='jmp'
end

jmp()


local function jmpc(o,c,name)
  lines[#lines+1]=util.format([[
void %sExec(z80* z)
{
  z->r.mptr=z->r.tm;

  %s
    z->r.pc=z->r.tm;
}

void %s(z80* z)
{ 
  %s
  %s
  %s
  z->r.q=0;
  z->T=4;
}
]],name,c,name,readI('pc','tm1',0,3,true),readI('pc','tm2',1,2,true),exec(name..'Exec',2,1))
  inst[o]=name
end

jmpc(0xc2+ls(0,3),'if(!(z->r.f & 0x40))','jmpnz')
jmpc(0xc2+ls(1,3),'if((z->r.f & 0x40))','jmpz')
jmpc(0xc2+ls(2,3),'if(!(z->r.f & 0x01))','jmpnc')
jmpc(0xc2+ls(3,3),'if((z->r.f & 0x01))','jmpc')
jmpc(0xc2+ls(4,3),'if(!(z->r.f & 0x04))','jmppo')
jmpc(0xc2+ls(5,3),'if((z->r.f & 0x04))','jmppe')
jmpc(0xc2+ls(6,3),'if(!(z->r.f & 0x80))','jmpp')
jmpc(0xc2+ls(7,3),'if((z->r.f & 0x80))','jmpm')


local function jr()
  lines[#lines+1]=util.format([[
void jrExec(z80* z)
{
  z->r.pc+=(int8_t)z->r.tm1;
  z->r.mptr=z->r.pc;
}

void jr(z80* z)
{
  %s
  %s
  %s
  %s
  %s
  %s
  z->r.q=0;
  z->T=4;
}
]],readI('pc','tm1',0,3,true),exec('jrExec',1,1,true,'pc'),con('pc',2,1),con('pc',3,1),con('pc',4,1),con('pc',5,1))
  inst[0x18]='jr'
end

jr()

local function jrc(o,c,name)
  lines[#lines+1]=util.format([[
void %sExec(z80* z)
{
  z->r.pc+=(int8_t)z->r.tm1;
  z->r.mptr=z->r.pc;
}

void %s(z80* z)
{
  %s
  %s
  {
    %s
    %s
    %s
    %s
    %s 
  }
  z->r.q=0;
  z->T=4;
}]],name,name,readI('pc','tm1',0,3,true),c,exec(name..'Exec',1,1,true,'pc'),con('pc',2,1),con('pc',3,1),con('pc',4,1),con('pc',5,1))
  inst[o]=name
end

jrc(0x20,'if(!(z->r.f & 0x40))','jrnz')
jrc(0x28,'if((z->r.f & 0x40))','jrz')
jrc(0x30,'if(!(z->r.f & 0x01))','jrnc')
jrc(0x38,'if((z->r.f & 0x01))','jrc')


local function jmpi(s,o,g)
  lines[#lines+1]=util.format([[
void jmpi_%s(z80* z)
{
  z->r.pc=z->r.%s;
  z->r.q=0;
  z->T=4;
}]],s,s)
  g[o]=util.format('jmpi_%s',s)
end

jmpi('hl',0xe9,inst)
jmpi('ix',0xe9,ddInst)
jmpi('iy',0xe9,fdInst)

local function djnz()
  lines[#lines+1]=util.format([[
void djnzExec(z80* z)
{
  z->r.pc+=(int8_t)z->r.tm1;
  z->r.mptr=z->r.pc;
}

void djnz(z80* z)
{
  %s
  %s
  z->r.b--;

  if(z->r.b)
  {
    %s
    %s
    %s
    %s
    %s
  }
  z->r.q=0;
  z->T=4;
}]],con('ir',0,1),readI('pc','tm1',1,3,true),exec('djnzExec',2,1,true,'pc'),con('pc',3,1),con('pc',4,1),con('pc',5,1),con('pc',6,1))
  inst[0x10]='djnz'
end

djnz()


local function call()
  lines[#lines+1]=util.format([[
void call(z80* z)
{
  //z->r.tm=z->r.pc;
  %s
  %s
  %s
  %s
  %s
  %s
  z->r.q=0;
  z->T=4;
}]],readI('pc','mptrl',0,3,true),readI('pc','mptrh',1,3,true),con('pc',2,1),writeDc('sp',high['pc'],3,3,true),writeDc('sp',low['pc'],4,2,true),exec('callccExec',5,1))
  inst[0xcd]='call'
end

call()


local function callc(o,c,name)
  lines[#lines+1]=util.format([[
void %sExec(z80* z)
{
  z->r.tm=z->r.pc;
  z->r.pc=z->r.mptr;
}

void %s(z80* z)
{
  %s
  %s
  %s
  {
    %s
    %s
    %s
  }
  z->r.q=0;
  z->T=4;
}]],name,name,readI('pc','mptrl',0,3,true),readI('pc','mptrh',1,3,true),c,exec(name..'Exec',2,1,true,'pc'),writeDc('sp','tm2',3,3,true),writeDc('sp','tm1',4,3,true))
  inst[o]=util.format('%s',name)
end

callc(0xc4+ls(0,3),'if(!(z->r.f & 0x40))','callnz')
callc(0xc4+ls(1,3),'if((z->r.f & 0x40))','callz')
callc(0xc4+ls(2,3),'if(!(z->r.f & 0x01))','callnc')
callc(0xc4+ls(3,3),'if((z->r.f & 0x01))','callc')
callc(0xc4+ls(4,3),'if(!(z->r.f & 0x04))','callpo')
callc(0xc4+ls(5,3),'if((z->r.f & 0x04))','callpe')
callc(0xc4+ls(6,3),'if(!(z->r.f & 0x80))','callp')
callc(0xc4+ls(7,3),'if((z->r.f & 0x80))','callm')

local function ret()
  lines[#lines+1]=util.format([[
void rett(z80* z)
{
  %s
  %s
  %s
  z->r.q=0;
  z->T=4;
}]],readI('sp',low['pc'],0,3,true),readI('sp',high['pc'],1,2,true),exec('rettExec',2,1))
  inst[0xc9]='rett'
end

ret()


local function retc(o,c,name)
  lines[#lines+1]=util.format([[
void %s(z80* z)
{
  %s
  %s
  {
    %s
    %s
    %s
  }

  z->r.q=0;
  z->T=4;
}]],name,con('ir',0,1),c,readI('sp',low['pc'],1,3,true),readI('sp',high['pc'],2,2,true),exec('rettExec',3,1))
  inst[o]=util.format('%s',name)
end

retc(0xc0+ls(0,3),'if(!(z->r.f & 0x40))','retnz')
retc(0xc0+ls(1,3),'if((z->r.f & 0x40))','retz')
retc(0xc0+ls(2,3),'if(!(z->r.f & 0x01))','retnc')
retc(0xc0+ls(3,3),'if((z->r.f & 0x01))','retc')
retc(0xc0+ls(4,3),'if(!(z->r.f & 0x04))','retpo')
retc(0xc0+ls(5,3),'if((z->r.f & 0x04))','retpe')
retc(0xc0+ls(6,3),'if(!(z->r.f & 0x80))','retp')
retc(0xc0+ls(7,3),'if((z->r.f & 0x80))','retm')

-- *Todo: interrepcion terminada.
local function reti()
  edInst[0x4d]='rett'
end

reti()

local function retn()
  lines[#lines+1]=util.format([[
void retn(z80* z)
{
  z->r.iff=z->r.iff2;
  %s
  %s
  %s
    
  z->r.q=0;
  z->T=4;
}]],readI('sp',low.pc,0,3,true),readI('sp',high.pc,1,2,true),exec('rettExec',2,1))
  edInst[0x45]='retn'
end

retn()

--undocumented
edInst[0x55]='retn'
edInst[0x5D]='retn'
edInst[0x65]='retn'
edInst[0x6D]='retn'
edInst[0x75]='retn'
edInst[0x7D]='retn'

local function rst(o)
  local s=band(o,0x38)
  lines[#lines+1]=util.format([[
void rst_%d(z80* z)
{
  %s
  z->r.tm=z->r.pc;
  z->r.pc=%d;
  %s
  %s
  %s

  z->r.q=0;
  z->T=4;
}]],s,con('ir',0,1),s,writeDc('sp','tm2',1,3,true),writeDc('sp','tm1',2,2,true),exec('rettExec',3,1))
  inst[o]=util.format('rst_%d',s)
end

for i=0,0x38,8 do
  rst(i+0xc7)
end


local function ina()
  lines[#lines+1]=util.format([[
void in_aExec(z80* z)
{
  z->r.tm=(z->r.a<<8) | z->r.tm1;
  z->r.mptr=z->r.tm+1;
}

void in_a(z80* z)
{
  %s
  %s
  %s
  z->r.tm2=z->r.a;
  z->r.q=0;
  z->T=4;
}]],readI('pc','tm1',0,2,true),exec('in_aExec',1,1),inPort('tm','a',2,4,true))
  inst[0xdb]=util.format('in_a')
end

ina()


local function inr(s,o)
  lines[#lines+1]=util.format([[
void inr_%sExec(z80* z)
{
  z->r.f=(z->r.f & 0x1) | (sz53pcFlags[z->r.%s] & 0xec);
  z->r.mptr=z->r.bc+1;
}

void inr_%s(z80* z)
{
  %s
  %s
  z->r.q=1;
  z->T=4;
}]],s,s,s,inPort('bc',s,0,4,true),exec('inr_'..s..'Exec',1,0))
  edInst[o]=util.format('inr_%s',s)
end

for k,v in pairs(r8) do
  inr(v,ls(k,3)+0x40)
end 

inr('tm1',0x70) -- undocumented

local function ini()
  lines[#lines+1]=util.format([[
void iniExec(z80* z)
{
  z->r.mptr=z->r.bc+1;
  z->r.b--;
  uint8_t c=z->r.c+1;
  uint8_t h=((z->r.tm1+c)>255)?0x11:0x0;
  z->r.f=(sz53cFlags[z->r.b] & 0xE8) | ((z->r.tm1 & 0x80) >> 6) | h | (sz53pcFlags[((z->r.tm1+c) & 0x7) ^ z->r.b] & 0x4);
}

void ini(z80* z)
{
  %s
  %s
  %s
  %s
  z->r.q=1;
  z->T=4;
}]],con('ir',0,1),inPort('bc','tm1',1,4,true),writeI('hl','tm1',2,2,true),exec('iniExec',3,1))
  edInst[0xa2]=util.format('ini')
end

ini()

local function inir()
  lines[#lines+1]=util.format([[
void inirExec(z80* z)
{
  z->r.mptr=z->r.bc+1;
  z->r.b--;
  uint8_t c=z->r.c+1;
  uint8_t h=((z->r.tm1+c)>255)?0x11:0x0;
  z->r.f=(sz53cFlags[z->r.b] & 0xE8) | ((z->r.tm1 & 0x80) >> 6) | h | (sz53pcFlags[((z->r.tm1+c) & 0x7) ^ z->r.b] & 0x4);

  if(z->r.b)
  {
    z->r.pc-=2;
    %s
    %s
    %s
    %s
    %s
  }
}

void inir(z80* z)
{
  z->r.aux=z->r.hl;
  %s
  %s
  %s
  %s
  z->r.q=1;
  z->T=4;
}]],con('aux',4,1),con('aux',5,1),con('aux',6,1),con('aux',7,1),con('aux',8,1),con('ir',0,1),inPort('bc','tm1',1,4,true),writeI('hl','tm1',2,2,true),exec('inirExec',3,1))
  edInst[0xb2]=util.format('inir')
end

inir()

local function ind()
  lines[#lines+1]=util.format([[
void indExec(z80* z)
{
  z->r.mptr=z->r.bc-1;
  z->r.b--;
  z->r.hl--;
  uint8_t c=z->r.c-1;
  uint8_t h=((z->r.tm1+c)>255)?0x11:0x0;
  z->r.f=(sz53cFlags[z->r.b] & 0xE8) | ((z->r.tm1 & 0x80) >> 6) | h | (sz53pcFlags[((z->r.tm1+c) & 0x7) ^ z->r.b] & 0x4);
}

void ind(z80* z)
{
  %s
  %s
  %s
  %s
  z->r.q=1;
  z->T=4;
}]],con('ir',0,1),inPort('bc','tm1',1,4,true),write('hl','tm1',2,2,true),exec('indExec',3,1))
  edInst[0xaa]=util.format('ind')
end

ind()

local function indr()
  lines[#lines+1]=util.format([[
void indrExec(z80* z)
{
  z->r.mptr=z->r.bc-1;
  z->r.b--;
  z->r.hl--;
  uint8_t c=z->r.c-1;
  uint8_t h=((z->r.tm1+c)>255)?0x11:0x0;
  z->r.f=(sz53cFlags[z->r.b] & 0xE8) | ((z->r.tm1 & 0x80) >> 6) | h | (sz53pcFlags[((z->r.tm1+c) & 0x7) ^ z->r.b] & 0x4);

  if(z->r.b)
  {
    z->r.pc-=2;
    %s
    %s
    %s
    %s
    %s
  }
}

void indr(z80* z)
{
  z->r.aux=z->r.hl;
  %s
  %s
  %s
  %s
  z->r.q=1;
  z->T=4;
}]],con('aux',4,1),con('aux',5,1),con('aux',6,1),con('aux',7,1),con('aux',8,1),con('ir',0,1),inPort('bc','tm1',1,4,true),write('hl','tm1',2,2,true),exec('indrExec',3,1))
  edInst[0xba]=util.format('indr')
end

indr()

local function outa()
  lines[#lines+1]=util.format([[
void out_aExec(z80* z)
{
  z->r.tm=(z->r.a<<8) | z->r.tm1;
  z->r.mptr=(z->r.a<<8) | ((z->r.tm1+1) & 0xff);
}

void out_a(z80* z)
{
  %s
  %s
  %s
  z->r.tm2=z->r.a;
  z->r.q=0;
  z->T=4;
}]],readI('pc','tm1',0,2,true),exec('out_aExec',1,1),outPort('tm','a',2,4,true))
  inst[0xd3]='out_a'
end

outa()

local function outr(s,o)
  lines[#lines+1]=util.format([[
void outr_%s(z80* z)
{
  %s
  z->r.q=0;
  z->r.mptr=z->r.bc+1;
  z->T=4;
}]],s,outPort('bc',s,0,4,true))
  edInst[o]=util.format('outr_%s',s)
end

local function out0(o)
  lines[#lines+1]=util.format([[
void out0(z80* z)
{
  z->r.tm1=0;
  %s
  z->r.mptr=z->r.bc+1;
  z->r.q=0;
  z->T=4;
}]],outPort('bc','tm1',0,4,true))
  edInst[o]=util.format('out0')
end

out0(0x71)

for k,v in pairs(r8) do
  outr(v,ls(k,3)+0x41)
end 

local function outi()
  lines[#lines+1]=util.format([[
void outiExec(z80* z)
{
  uint8_t h=((z->r.tm1+z->r.l)>255)?0x11:0x0;
  z->r.f=(sz53cFlags[z->r.b] & 0xE8) | ((z->r.tm1 & 0x80) >> 6) | h | (sz53pcFlags[((z->r.tm1+z->r.l) & 0x7) ^ z->r.b] & 0x4);
}

void outi(z80* z)
{
  z->r.b--;
  z->r.mptr=z->r.bc+1;
  %s
  %s  
  %s
  %s
  
  z->r.q=1;
  z->T=4;
}]],con('ir',0,1),readI('hl','tm1',1,3,true),outPort('bc','tm1',2,3,true),exec('outiExec',3,1))
  edInst[0xa3]=util.format('outi')
end

outi()

local function otir()
  lines[#lines+1]=util.format([[
void otirExec(z80* z)
{
  if(z->r.b)
  {
    z->r.pc-=2;
    %s
    %s
    %s
    %s
    %s 
  }
  uint8_t h=((z->r.tm1+z->r.l)>255)?0x11:0x0;
  z->r.f=(sz53cFlags[z->r.b] & 0xE8) | ((z->r.tm1 & 0x80) >> 6) | h | (sz53pcFlags[((z->r.tm1+z->r.l) & 0x7) ^ z->r.b] & 0x4);
}

void otir(z80* z)
{
  z->r.aux=z->r.bc;
  z->r.b--;
  z->r.mptr=z->r.bc+1;
  %s
  %s
  %s
  %s
  
  z->r.q=1;
  z->T=4;
}]],con('aux',4,1),con('aux',5,1),con('aux',6,1),con('aux',7,1),con('aux',8,1),con('ir',0,1),readI('hl','tm1',1,3,true),outPort('bc','tm1',2,3,true),exec('otirExec',3,1))
  edInst[0xb3]=util.format('otir')
end

otir()

local function outd()
  lines[#lines+1]=util.format([[
void outdExec(z80* z)
{
  z->r.hl--;
  uint8_t h=((z->r.tm1+z->r.l)>255)?0x11:0x0;
  z->r.f=(sz53cFlags[z->r.b] & 0xE8) | ((z->r.tm1 & 0x80) >> 6) | h | (sz53pcFlags[((z->r.tm1+z->r.l) & 0x7) ^ z->r.b] & 0x4);
}

void outd(z80* z)
{
  z->r.b--;
  z->r.mptr=z->r.bc-1;
  %s
  %s 
  %s
  %s 
  
  z->r.q=1;
  z->T=4;
}]],con('ir',0,1),read('hl','tm1',1,3,true),outPort('bc','tm1',2,3,true),exec('outdExec',3,1))
  edInst[0xab]='outd'
end

outd()

local function otdr()
  lines[#lines+1]=util.format([[
void otdrExec(z80* z)
{
  z->r.hl--;
  if(z->r.b)
  {
    z->r.pc-=2;
    %s
    %s
    %s
    %s
    %s
  }
  uint8_t h=((z->r.tm1+z->r.l)>255)?0x11:0x0;
  z->r.f=(sz53cFlags[z->r.b] & 0xE8) | ((z->r.tm1 & 0x80) >> 6) | h | (sz53pcFlags[((z->r.tm1+z->r.l) & 0x7) ^ z->r.b] & 0x4);
}

void otdr(z80* z)
{
  z->r.aux=z->r.bc;
  z->r.b--;
  z->r.mptr=z->r.bc-1;
  %s
  %s
  %s
  %s
  
  z->r.q=1;
  z->T=4;
}]],con('aux',4,1),con('aux',5,1),con('aux',6,1),con('aux',7,1),con('aux',8,1),con('ir',0,1),read('hl','tm1',1,3,true),outPort('bc','tm1',2,3,true),exec('otdrExec',3,1))
  edInst[0xbb]='otdr'
end

otdr()

--interrupts
lines[#lines+1]=util.format([[
void z80_nmi(z80 *z)
{
  z->r.tm=z->r.pc;
  z->r.pc=z->r.mptr=0x0066;
  %s
  %s
  z->T=5;
}
]],writeDc('sp','tm2',0,3),writeDc('sp','tm1',1,3))

--tm1 contiene el valor del bus.
lines[#lines+1]=util.format([[
void z80_i0(z80 *z)
{
  nInst[z->r.tm1](z);
  z->T+=2;
}
]])

--tm1 contiene el valor del bus.
lines[#lines+1]=util.format([[
void z80_i1(z80 *z)
{
  nInst[0xff](z);
  z->T+=2;
}
]])

--tm1 contiene el valor del bus.
lines[#lines+1]=util.format([[
void i2Exec(z80 *z)
{
  z->r.mptr=z->r.pc;
}

void z80_i2(z80 *z)
{
  z->r.tm2=z->r.i;
  %s
  %s
  %s
  %s
  %s
  z->T=7;
}
]],writeDc('sp','pch',0,3,true),writeDc('sp','pcl',1,3,true),readI('tm','pcl',2,3,true),read('tm','pch',3,2,true),exec('i2Exec',4,1))

--Instruction init
lines[#lines+1]=[[
void z80_init()
{
  //Normal opcodes]]

for i=0,0xff do
  lines[#lines+1]=util.format('  nInst[0x%.2x]=%s;',i,inst[i] and inst[i] or inst[0])
end

lines[#lines+1]=[[

  //0xcb opcodes
]]

for i=0,0xff do
  lines[#lines+1]=util.format('  cbInst[0x%.2x]=%s;',i,cbInst[i] and cbInst[i] or inst[0])
end


lines[#lines+1]=[[

  //0xdd opcodes
]]

for i=0,0xff do
  lines[#lines+1]=util.format('  ddInst[0x%.2x]=%s;',i,ddInst[i] and ddInst[i] or inst[i])
end

lines[#lines+1]=[[

  //0xddcb opcodes
]]

for i=0,0xff do
  lines[#lines+1]=util.format('  ddcbInst[0x%.2x]=%s;',i,ddcbInst[i] and ddcbInst[i] or inst[0])
end


lines[#lines+1]=[[

  //0xed opcodes
]]

for i=0,0xff do
  lines[#lines+1]=util.format('  edInst[0x%.2x]=%s;',i,edInst[i] and edInst[i] or inst[0])
end

lines[#lines+1]=[[

  //0xfd opcodes
]]

for i=0,0xff do
  lines[#lines+1]=util.format('  fdInst[0x%.2x]=%s;',i,fdInst[i] and fdInst[i] or inst[i])
end

lines[#lines+1]=[[

  //0xfdcb opcodes
]]

for i=0,0xff do
  lines[#lines+1]=util.format('  fdcbInst[0x%.2x]=%s;',i,fdcbInst[i] and fdcbInst[i] or inst[0])
end

lines[#lines+1]='}'

file.writeLines(filename,lines)